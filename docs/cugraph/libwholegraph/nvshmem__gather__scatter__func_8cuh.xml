<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="nvshmem__gather__scatter__func_8cuh" kind="file" language="C++">
    <compoundname>nvshmem_gather_scatter_func.cuh</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">/*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Copyright<sp/>(c)<sp/>2023-2024,<sp/>NVIDIA<sp/>CORPORATION.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Licensed<sp/>under<sp/>the<sp/>Apache<sp/>License,<sp/>Version<sp/>2.0<sp/>(the<sp/>&quot;License&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>you<sp/>may<sp/>not<sp/>use<sp/>this<sp/>file<sp/>except<sp/>in<sp/>compliance<sp/>with<sp/>the<sp/>License.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>You<sp/>may<sp/>obtain<sp/>a<sp/>copy<sp/>of<sp/>the<sp/>License<sp/>at</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/>http://www.apache.org/licenses/LICENSE-2.0</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Unless<sp/>required<sp/>by<sp/>applicable<sp/>law<sp/>or<sp/>agreed<sp/>to<sp/>in<sp/>writing,<sp/>software</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>distributed<sp/>under<sp/>the<sp/>License<sp/>is<sp/>distributed<sp/>on<sp/>an<sp/>&quot;AS<sp/>IS&quot;<sp/>BASIS,</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>WITHOUT<sp/>WARRANTIES<sp/>OR<sp/>CONDITIONS<sp/>OF<sp/>ANY<sp/>KIND,<sp/>either<sp/>express<sp/>or<sp/>implied.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>See<sp/>the<sp/>License<sp/>for<sp/>the<sp/>specific<sp/>language<sp/>governing<sp/>permissions<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>limitations<sp/>under<sp/>the<sp/>License.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">#ifdef<sp/>WITH_NVSHMEM_SUPPORT</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>once</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;gather_scatter_func.cuh&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;nvshmem_device_reference.cuh&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;wholememory/communicator.hpp&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;wholememory/device_reference.cuh&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;wholememory/global_reference.h&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;wholememory/memory_handle.hpp&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;wholememory/tensor_description.h&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;wholememory_ops/register.hpp&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;wholememory_ops/temp_memory_handle.hpp&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;wholememory_ops/thrust_allocator.hpp&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;cub/cub.cuh&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;cuda_bf16.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;cuda_fp16.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;nvshmem.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;nvshmemx.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;thrust/sequence.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;thrust/unique.h&gt;</highlight></codeline>
<codeline><highlight class="normal">namespace<sp/>wholememory_ops<sp/>{</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>InputIteratorT,<sp/>typename<sp/>OffsetT,<sp/>typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">__device__<sp/>__forceinline__<sp/>OffsetT<sp/>UpperBound(InputIteratorT<sp/>input,<sp/>OffsetT<sp/>num_items,<sp/>T<sp/>val)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OffsetT<sp/>retval<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(num_items<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OffsetT<sp/>half<sp/>=<sp/>num_items<sp/>&gt;&gt;<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(val<sp/>&lt;<sp/>input[retval<sp/>+<sp/>half])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>num_items<sp/>=<sp/>half;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>retval<sp/><sp/><sp/><sp/>=<sp/>retval<sp/>+<sp/>(half<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>num_items<sp/>=<sp/>num_items<sp/>-<sp/>(half<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>retval;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>InputIteratorT,<sp/>typename<sp/>OffsetT,<sp/>typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">__device__<sp/>__forceinline__<sp/>OffsetT<sp/>LowerBound(InputIteratorT<sp/>input,<sp/>OffsetT<sp/>num_items,<sp/>T<sp/>val)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OffsetT<sp/>retval<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(num_items<sp/>&gt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OffsetT<sp/>half<sp/>=<sp/>num_items<sp/>&gt;&gt;<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(input[retval<sp/>+<sp/>half]<sp/>&lt;<sp/>val)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>retval<sp/><sp/><sp/><sp/>=<sp/>retval<sp/>+<sp/>(half<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>num_items<sp/>=<sp/>num_items<sp/>-<sp/>(half<sp/>+<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>num_items<sp/>=<sp/>half;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>retval;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>IndexT&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>sort_index_in_pair(const<sp/>void*<sp/>indices_before_sort,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int64_t<sp/>indice_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void*<sp/>indices_after_sort,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IndexT*<sp/>raw_indices,<sp/><sp/>//<sp/>output</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_comm_t<sp/>wm_comm,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wm_thrust_allocator*<sp/>p_thrust_allocator,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStream_t<sp/>stream)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wm_thrust_allocator&amp;<sp/>allocator<sp/>=<sp/>*p_thrust_allocator;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT*<sp/>seq_indices<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>reinterpret_cast&lt;IndexT*&gt;(allocator.allocate(indice_count<sp/>*<sp/>sizeof(IndexT)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>thrust::sequence(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>thrust::cuda::par_nosync(allocator).on(stream),<sp/>seq_indices,<sp/>seq_indices<sp/>+<sp/>indice_count,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>TODO:<sp/>use<sp/>unsigned<sp/>type<sp/>(wm_ops::UTypeT)<sp/>can<sp/>put<sp/>all<sp/>negative<sp/>indices<sp/>at<sp/>last.<sp/>But<sp/>maybe</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>later...<sp/>using<sp/>UTypeT<sp/>=<sp/>typename<sp/>UnsignedType&lt;IndexT&gt;::UType;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto<sp/>indices_to_sort<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>static_cast&lt;const<sp/>IndexT*&gt;(indices_before_sort);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto<sp/>sorted_indice<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>static_cast&lt;IndexT*&gt;(indices_after_sort);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void*<sp/>cub_temp_storage<sp/><sp/><sp/><sp/>=<sp/>nullptr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>temp_storage_bytes<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cub::DeviceRadixSort::SortPairs(cub_temp_storage,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>temp_storage_bytes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>indices_to_sort,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sorted_indice,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>seq_indices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>raw_indices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>indice_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sizeof(IndexT)<sp/>*<sp/>8,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stream);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cub_temp_storage<sp/>=<sp/>allocator.allocate(temp_storage_bytes);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cub::DeviceRadixSort::SortPairs(cub_temp_storage,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>temp_storage_bytes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>indices_to_sort,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sorted_indice,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>seq_indices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>raw_indices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>indice_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sizeof(IndexT)<sp/>*<sp/>8,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stream);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>allocator.deallocate(reinterpret_cast&lt;char*&gt;(seq_indices),<sp/>indice_count<sp/>*<sp/>sizeof(IndexT));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>allocator.deallocate(static_cast&lt;char*&gt;(cub_temp_storage),<sp/>temp_storage_bytes);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>EmbeddingT,<sp/>typename<sp/>IndexT,<sp/>int<sp/>ALIGNMENT<sp/>=<sp/>1,<sp/>bool<sp/>USE_IBGDA<sp/>=<sp/>true&gt;</highlight></codeline>
<codeline><highlight class="normal">__global__<sp/>void<sp/>gather_func_with_nvshmem_sort_idxs_kernel(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_nvshmem_ref_t<sp/>embeding_nvshmem_ref,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_matrix_description_t<sp/>embedding_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IndexT*<sp/>__restrict__<sp/>sorted_index,<sp/><sp/>//<sp/>sorted<sp/>(input)<sp/>index<sp/>to<sp/>select</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IndexT*<sp/>__restrict__<sp/>output_index,<sp/><sp/>//<sp/>output<sp/>index<sp/>to<sp/>drop<sp/>in<sp/>output<sp/>array</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>indice_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>max_blocks_for_local,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>intra_node_ranks,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>node_rank,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>embedding_entry_per_rank,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EmbeddingT*<sp/>__restrict__<sp/>temp_output,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_matrix_description_t<sp/>output_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>threads_per_group)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int64_t<sp/>local_index_lowerbound<sp/>=<sp/>node_rank<sp/>*<sp/>intra_node_ranks<sp/>*<sp/>embedding_entry_per_rank;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int64_t<sp/>local_index_upperbound<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(node_rank<sp/>+<sp/>1)<sp/>*<sp/>intra_node_ranks<sp/>*<sp/>embedding_entry_per_rank;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int64_t<sp/>local_index_start<sp/><sp/>=<sp/>LowerBound(sorted_index,<sp/>indice_count,<sp/>local_index_lowerbound);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int64_t<sp/>local_index_length<sp/>=<sp/>UpperBound(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sorted_index<sp/>+<sp/>local_index_start,<sp/>indice_count<sp/>-<sp/>local_index_start,<sp/>local_index_upperbound<sp/>-<sp/>1);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>embedding_size<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>embedding_desc.sizes[1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>embedding_stride<sp/>=<sp/>embedding_desc.stride;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>output_stride<sp/><sp/><sp/><sp/>=<sp/>output_desc.stride;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>nvshmem_device_reference&lt;EmbeddingT&gt;<sp/>embedding_nvshmem_device_ref{embeding_nvshmem_ref};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(blockIdx.x<sp/>&gt;=<sp/>max_blocks_for_local)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>int64_t<sp/>thread_id<sp/>=<sp/>(blockIdx.x<sp/>-<sp/>max_blocks_for_local)<sp/>*<sp/>blockDim.x<sp/>+<sp/>threadIdx.x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int64_t<sp/>row_id<sp/>=<sp/>thread_id;<sp/>row_id<sp/>&lt;<sp/>indice_count<sp/>-<sp/>local_index_length;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>row_id<sp/>+=<sp/>(gridDim.x<sp/>-<sp/>max_blocks_for_local)<sp/>*<sp/>blockDim.x)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>int64_t<sp/>scaled_row_id<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>row_id<sp/>&lt;<sp/>local_index_start<sp/>?<sp/>row_id<sp/>:<sp/>row_id<sp/>+<sp/>local_index_length;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int64_t<sp/>embedding_table_idx<sp/>=<sp/>sorted_index[scaled_row_id];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>int64_t<sp/>output_idx<sp/><sp/><sp/><sp/>=<sp/>output_index[scaled_row_id];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(embedding_table_idx<sp/>&lt;<sp/>0)<sp/>continue;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>EmbeddingT*<sp/>temp_output_ptr<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>temp_output<sp/>+<sp/>output_stride<sp/>*<sp/>output_idx<sp/>+<sp/>output_desc.storage_offset;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int64_t<sp/>embedding_offset<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>embedding_desc.storage_offset<sp/>+<sp/>embedding_table_idx<sp/>*<sp/>embedding_stride;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>dest_rank<sp/>=<sp/>embedding_nvshmem_device_ref.dest_rank(embedding_offset);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>EmbeddingT*<sp/>symmetric_address<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>embedding_nvshmem_device_ref.symmetric_address(embedding_offset);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(USE_IBGDA)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nvshmem_getmem(temp_output_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_cast&lt;const<sp/>EmbeddingT*&gt;(symmetric_address),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>embedding_size<sp/>*<sp/>sizeof(EmbeddingT),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dest_rank);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nvshmem_getmem_nbi(temp_output_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_cast&lt;const<sp/>EmbeddingT*&gt;(symmetric_address),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>embedding_size<sp/>*<sp/>sizeof(EmbeddingT),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dest_rank);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>one<sp/>embedding<sp/>per<sp/>block</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>int<sp/>thread_id_in_group<sp/>=<sp/>threadIdx.x<sp/>%<sp/>threads_per_group;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>int<sp/>group_id_in_block<sp/><sp/>=<sp/>threadIdx.x<sp/>/<sp/>threads_per_group;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>int<sp/>groups_per_block<sp/><sp/><sp/>=<sp/>blockDim.x<sp/>/<sp/>threads_per_group;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>int<sp/>group_id<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>blockIdx.x<sp/>*<sp/>groups_per_block<sp/>+<sp/>group_id_in_block;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int64_t<sp/>row_id<sp/>=<sp/>local_index_start<sp/>+<sp/>group_id;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>row_id<sp/>&lt;<sp/>local_index_start<sp/>+<sp/>local_index_length;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>row_id<sp/>+=<sp/>max_blocks_for_local<sp/>*<sp/>groups_per_block)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>IndexT<sp/>embedding_table_idx<sp/>=<sp/>sorted_index[row_id];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>IndexT<sp/>output_idx<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>output_index[row_id];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(embedding_table_idx<sp/>&lt;<sp/>0)<sp/>continue;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>printf(&quot;*********in<sp/>kernel<sp/>:<sp/>idx_id<sp/>=%ld<sp/>,<sp/>embedding_table_idx:%ld,<sp/>output_idx:%ld</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>,\n&quot;,idx_id,<sp/>int64_t(embedding_table_idx),int64_t(<sp/>output_idx));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>EmbeddingT*<sp/>temp_output_ptr<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>temp_output<sp/>+<sp/>output_stride<sp/>*<sp/>output_idx<sp/>+<sp/>output_desc.storage_offset;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int64_t<sp/>embedding_offset<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>embedding_desc.storage_offset<sp/>+<sp/>embedding_table_idx<sp/>*<sp/>embedding_stride;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>EmbeddingT*<sp/>peer_embedding_ptr<sp/>=<sp/>static_cast&lt;EmbeddingT*&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nvshmem_ptr(embedding_nvshmem_device_ref.symmetric_address(embedding_offset),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>embedding_nvshmem_device_ref.dest_rank(embedding_offset)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(peer_embedding_ptr<sp/>==<sp/>nullptr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;Error:<sp/>Could<sp/>not<sp/>find<sp/>peer<sp/>NVSHMEM<sp/>array.\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__trap();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>emb_idx<sp/>=<sp/>thread_id_in_group<sp/>*<sp/>ALIGNMENT;<sp/>emb_idx<sp/>&lt;<sp/>embedding_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>emb_idx<sp/>+=<sp/>ALIGNMENT<sp/>*<sp/>threads_per_group)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mov_data&lt;sizeof(EmbeddingT)<sp/>*<sp/>ALIGNMENT&gt;(temp_output_ptr<sp/>+<sp/>emb_idx,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>peer_embedding_ptr<sp/>+<sp/>emb_idx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>EmbeddingT,<sp/>typename<sp/>OutputT,<sp/>int<sp/>ALIGNMENT<sp/>=<sp/>1&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">__global__<sp/>void<sp/>embedding_output_convert_date_type_kernel(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OutputT*<sp/>output,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>EmbeddingT*<sp/>input,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>embedding_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>embedding_dim,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_matrix_description_t<sp/>output_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_matrix_description_t<sp/>input_desc)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>thread_idx<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>threadIdx.x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>output_stride<sp/>=<sp/>output_desc.stride;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>input_stride<sp/><sp/>=<sp/>input_desc.stride;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>typed_data_vector&lt;EmbeddingT,<sp/>ALIGNMENT&gt;<sp/>input_vector;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>typed_data_vector&lt;OutputT,<sp/>ALIGNMENT&gt;<sp/>output_vector;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int64_t<sp/>output_idx<sp/>=<sp/>static_cast&lt;int64_t&gt;(blockIdx.x)<sp/>*<sp/>blockDim.y<sp/>+<sp/>threadIdx.y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>output_idx<sp/>&lt;<sp/>embedding_count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>output_idx<sp/>+=<sp/>static_cast&lt;int64_t&gt;(gridDim.x)<sp/>*<sp/>blockDim.y)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OutputT*<sp/>output_ptr<sp/><sp/>=<sp/>output<sp/>+<sp/>output_desc.storage_offset<sp/>+<sp/>output_stride<sp/>*<sp/>output_idx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int64_t<sp/>input_offset<sp/>=<sp/>output_idx<sp/>*<sp/>input_stride<sp/>+<sp/>input_desc.storage_offset;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>emb_idx<sp/>=<sp/>thread_idx<sp/>*<sp/>ALIGNMENT;<sp/>emb_idx<sp/>&lt;<sp/>embedding_dim;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>emb_idx<sp/>+=<sp/>ALIGNMENT<sp/>*<sp/>blockDim.x)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>mov_data&lt;sizeof(EmbeddingT)<sp/>*<sp/>ALIGNMENT&gt;(&amp;input_vector,<sp/>input<sp/>+<sp/>input_offset<sp/>+<sp/>emb_idx);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#pragma<sp/>unroll</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>sub_idx<sp/>=<sp/>0;<sp/>sub_idx<sp/>&lt;<sp/>ALIGNMENT;<sp/>sub_idx++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typed_data_vector_at(output_vector,<sp/>sub_idx)<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>convert_type&lt;EmbeddingT,<sp/>OutputT&gt;(typed_data_vector_at(input_vector,<sp/>sub_idx));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>mov_data&lt;sizeof(OutputT)<sp/>*<sp/>ALIGNMENT&gt;(output_ptr<sp/>+<sp/>emb_idx,<sp/>&amp;output_vector);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>EmbeddingT,<sp/>typename<sp/>OutputT&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>embedding_output_convert_date_type_temp_func(OutputT*<sp/>output,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>EmbeddingT*<sp/>input,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int64_t<sp/>embedding_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int64_t<sp/>embedding_dim,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t<sp/>output_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t<sp/>input_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStream_t<sp/>stream)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(embedding_count<sp/>==<sp/>0<sp/>||<sp/>input_desc.sizes[1]<sp/>==<sp/>0<sp/>||<sp/>output_desc.sizes[0]<sp/>==<sp/>0)<sp/>return;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>im_alignment<sp/><sp/><sp/>=<sp/>determine_memory_alignment_elt_count(input,<sp/>input_desc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>om_alignment<sp/><sp/><sp/>=<sp/>determine_memory_alignment_elt_count(output,<sp/>output_desc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>alignment<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>std::min&lt;int&gt;(im_alignment,<sp/>om_alignment);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>embedding_size<sp/>=<sp/>embedding_dim;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>thread_x<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>wholememory::div_rounding_up_safe&lt;int&gt;(embedding_size,<sp/>alignment);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>thread_x<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>std::min(thread_x,<sp/>256);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>thread_y<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(thread_x<sp/>&lt;<sp/>64)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>power2_thread_x<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(;<sp/>power2_thread_x<sp/>&lt;<sp/>thread_x;<sp/>power2_thread_x<sp/>*=<sp/>2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>thread_x<sp/>=<sp/>power2_thread_x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>thread_y<sp/>=<sp/>64<sp/>/<sp/>thread_x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>block_count_64<sp/>=<sp/>(embedding_count<sp/>+<sp/>thread_y<sp/>-<sp/>1)<sp/>/<sp/>thread_y;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>block_count<sp/>=<sp/>block_count_64<sp/>&gt;=<sp/>INT_MAX<sp/>?<sp/>INT_MAX<sp/>/<sp/>4<sp/>:<sp/>static_cast&lt;int&gt;(block_count_64);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>dim3<sp/>block_dim(thread_x,<sp/>thread_y,<sp/>1);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>(*kernel_fn)(OutputT*,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>EmbeddingT*,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int64_t,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int64_t,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t)<sp/>=<sp/>nullptr;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>switch<sp/>(alignment)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>16:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>kernel_fn<sp/>=<sp/>embedding_output_convert_date_type_kernel&lt;EmbeddingT,<sp/>OutputT,<sp/>16&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>8:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>kernel_fn<sp/>=<sp/>embedding_output_convert_date_type_kernel&lt;EmbeddingT,<sp/>OutputT,<sp/>8&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>4:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>kernel_fn<sp/>=<sp/>embedding_output_convert_date_type_kernel&lt;EmbeddingT,<sp/>OutputT,<sp/>4&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>2:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>kernel_fn<sp/>=<sp/>embedding_output_convert_date_type_kernel&lt;EmbeddingT,<sp/>OutputT,<sp/>2&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>1:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>kernel_fn<sp/>=<sp/>embedding_output_convert_date_type_kernel&lt;EmbeddingT,<sp/>OutputT,<sp/>1&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>default:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>WHOLEMEMORY_FAIL(&quot;embedding_output_convert_date_type<sp/>func<sp/>alignment=%d.&quot;,<sp/>alignment);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>kernel_fn&lt;&lt;&lt;block_count,<sp/>block_dim,<sp/>0,<sp/>stream&gt;&gt;&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>output,<sp/>input,<sp/>embedding_count,<sp/>embedding_dim,<sp/>output_desc,<sp/>input_desc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>WM_CUDA_CHECK(cudaGetLastError());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>EmbeddingT,<sp/>typename<sp/>IndexT,<sp/>typename<sp/>OutputT&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>nvshmem_gather_temp_get_mem_sort_idx_func(wholememory_comm_t<sp/>wm_comm,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_nvshmem_ref_t<sp/>embeding_nvshmem_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t<sp/>embedding_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>void*<sp/>indices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int64_t<sp/>indice_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void*<sp/>output,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void*<sp/>temp_output,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t<sp/>output_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_t<sp/>embedding_entry_count_per_rank,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_env_func_t*<sp/>p_env_fns,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStream_t<sp/>stream,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>gather_sms)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wm_thrust_allocator<sp/>thrust_allocator(p_env_fns);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(indice_count<sp/>==<sp/>0<sp/>||<sp/>embedding_desc.sizes[1]<sp/>==<sp/>0)<sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>temp_memory_handle<sp/>dev_raw_indice(p_env_fns);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT*<sp/>dev_raw_indice_ptr<sp/>=<sp/>static_cast&lt;IndexT*&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dev_raw_indice.device_malloc(indice_count,<sp/>get_wholememory_dtype&lt;IndexT&gt;()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>temp_memory_handle<sp/>dev_sorted_indice(p_env_fns);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void*<sp/>dev_sorted_indice_ptr<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dev_sorted_indice.device_malloc(indice_count,<sp/>get_wholememory_dtype&lt;IndexT&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_matrix_description_t<sp/>temp_output_desc<sp/>=<sp/>output_desc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>temp_output_desc.storage_offset<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>sort_index_in_pair(indices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>indice_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dev_sorted_indice_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dev_raw_indice_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wm_comm,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;thrust_allocator,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stream);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>intra_node_rank_num<sp/>=<sp/>wm_comm-&gt;intra_node_rank_num;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>node_id<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>wm_comm-&gt;world_rank<sp/>/<sp/>wm_comm-&gt;intra_node_rank_num;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto<sp/>ret_data<sp/><sp/><sp/><sp/><sp/>=<sp/>static_cast&lt;EmbeddingT*&gt;(temp_output);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto<sp/>sorted_index<sp/>=<sp/>static_cast&lt;IndexT*&gt;(dev_sorted_indice_ptr);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>wm_alignment<sp/>=<sp/>determine_wholememory_alignment_elt_count(embedding_desc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>mm_alignment<sp/>=<sp/>determine_memory_alignment_elt_count(temp_output,<sp/>temp_output_desc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>alignment<sp/><sp/><sp/><sp/>=<sp/>std::min&lt;int&gt;(wm_alignment,<sp/>mm_alignment);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>char*<sp/>use_ibgda<sp/>=<sp/>std::getenv(&quot;NVSHMEM_IB_ENABLE_IBGDA&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>use_ibgda_flag<sp/><sp/><sp/>=<sp/>((use_ibgda<sp/>!=<sp/>nullptr)<sp/>&amp;&amp;<sp/>(strcmp(use_ibgda,<sp/>&quot;1&quot;)<sp/>==<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>(*gather_nvshmem_kernel_fn)(wholememory_nvshmem_ref_t,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IndexT*,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IndexT*,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int64_t,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>int,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>int,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>int,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_t,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>EmbeddingT*,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>int)<sp/>=<sp/>nullptr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>switch<sp/>(alignment)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>16:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>gather_nvshmem_kernel_fn<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>use_ibgda_flag<sp/>?<sp/>gather_func_with_nvshmem_sort_idxs_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>16,<sp/>true&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>gather_func_with_nvshmem_sort_idxs_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>16,<sp/>false&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>8:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>gather_nvshmem_kernel_fn<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>use_ibgda_flag<sp/>?<sp/>gather_func_with_nvshmem_sort_idxs_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>8,<sp/>true&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>gather_func_with_nvshmem_sort_idxs_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>8,<sp/>false&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>4:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>gather_nvshmem_kernel_fn<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>use_ibgda_flag<sp/>?<sp/>gather_func_with_nvshmem_sort_idxs_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>4,<sp/>true&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>gather_func_with_nvshmem_sort_idxs_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>4,<sp/>false&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>2:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>gather_nvshmem_kernel_fn<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>use_ibgda_flag<sp/>?<sp/>gather_func_with_nvshmem_sort_idxs_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>2,<sp/>true&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>gather_func_with_nvshmem_sort_idxs_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>2,<sp/>false&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>1:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>gather_nvshmem_kernel_fn<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>use_ibgda_flag<sp/>?<sp/>gather_func_with_nvshmem_sort_idxs_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>1,<sp/>true&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>gather_func_with_nvshmem_sort_idxs_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>1,<sp/>false&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>default:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>WHOLEMEMORY_FAIL(&quot;gather<sp/>func<sp/>alignment=%d.&quot;,<sp/>alignment);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>block_threshold<sp/><sp/><sp/><sp/><sp/>=<sp/>64;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>max_blocks<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>1024;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>constexpr<sp/>int<sp/>WARP_SIZE<sp/>=<sp/>32;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>max_threads_per_block<sp/><sp/><sp/>=<sp/>256;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>num_threads_per_feature<sp/>=<sp/>std::min&lt;int64_t&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>max_threads_per_block,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>((embedding_desc.sizes[1]<sp/>/<sp/>alignment)<sp/>+<sp/>WARP_SIZE<sp/>-<sp/>1)<sp/>/<sp/>WARP_SIZE<sp/>*<sp/>WARP_SIZE);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>block_size<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(max_threads_per_block<sp/>/<sp/>num_threads_per_feature)<sp/>*<sp/>num_threads_per_feature;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>ngroup_per_block<sp/>=<sp/>block_size<sp/>/<sp/>num_threads_per_feature;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>num_blocks<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::min(max_blocks,<sp/>static_cast&lt;int&gt;(indice_count<sp/>+<sp/>ngroup_per_block)<sp/>/<sp/>ngroup_per_block);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>re-adjust<sp/>num_blocks/block_threshold<sp/>to<sp/>make<sp/>at<sp/>least<sp/>1<sp/>block<sp/>available<sp/>for<sp/>nvshmem<sp/>remote<sp/>get</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(num_blocks<sp/>&lt;<sp/>block_threshold)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>block_threshold<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(num_blocks<sp/>==<sp/>1)<sp/>num_blocks<sp/>=<sp/>2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>gather_nvshmem_kernel_fn&lt;&lt;&lt;num_blocks,<sp/>block_size,<sp/>0,<sp/>stream&gt;&gt;&gt;(embeding_nvshmem_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>embedding_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sorted_index,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dev_raw_indice_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>indice_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block_threshold,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>intra_node_rank_num,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_id,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>embedding_entry_count_per_rank,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret_data,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>temp_output_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>num_threads_per_feature);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(!use_ibgda_flag)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>nvshmemx_quiet_on_stream(stream);<sp/><sp/>//<sp/>wait<sp/>transfer</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>output_ele_size<sp/>=<sp/>wholememory_get_memory_element_count_from_matrix(&amp;output_desc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>constexpr<sp/>(sizeof(EmbeddingT)<sp/>==<sp/>sizeof(OutputT))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>WM_CUDA_CHECK(cudaMemcpyAsync(static_cast&lt;OutputT*&gt;(output)<sp/>+<sp/>output_desc.storage_offset,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>temp_output,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>output_ele_size<sp/>*<sp/>sizeof(OutputT),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMemcpyDeviceToDevice,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stream));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>embedding_output_convert_date_type_temp_func&lt;EmbeddingT,<sp/>OutputT&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>static_cast&lt;OutputT*&gt;(output),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>static_cast&lt;EmbeddingT*&gt;(temp_output),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>indice_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>embedding_desc.sizes[1],</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>output_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>temp_output_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>stream);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>WM_CUDA_CHECK(cudaGetLastError());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>(void)gather_sms;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>EmbeddingT,<sp/>typename<sp/>IndexT,<sp/>int<sp/>ALIGNMENT<sp/>=<sp/>1,<sp/>bool<sp/>USE_IBGDA<sp/>=<sp/>true&gt;</highlight></codeline>
<codeline><highlight class="normal">__global__<sp/>void<sp/>scatter_func_with_nvshmem_sort_idxs_kernel(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EmbeddingT*<sp/>__restrict__<sp/>temp_input,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_matrix_description_t<sp/>temp_input_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_nvshmem_ref_t<sp/>embeding_nvshmem_ref,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_matrix_description_t<sp/>embedding_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IndexT*<sp/>__restrict__<sp/>sorted_index,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IndexT*<sp/>__restrict__<sp/>input_index,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>indice_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>max_blocks_for_local,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>intra_node_ranks,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>node_rank,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>embedding_entry_per_rank,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>threads_per_group)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int64_t<sp/>local_index_lowerbound<sp/>=<sp/>node_rank<sp/>*<sp/>intra_node_ranks<sp/>*<sp/>embedding_entry_per_rank;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int64_t<sp/>local_index_upperbound<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(node_rank<sp/>+<sp/>1)<sp/>*<sp/>intra_node_ranks<sp/>*<sp/>embedding_entry_per_rank;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int64_t<sp/>local_index_start<sp/><sp/>=<sp/>LowerBound(sorted_index,<sp/>indice_count,<sp/>local_index_lowerbound);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int64_t<sp/>local_index_length<sp/>=<sp/>UpperBound(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sorted_index<sp/>+<sp/>local_index_start,<sp/>indice_count<sp/>-<sp/>local_index_start,<sp/>local_index_upperbound<sp/>-<sp/>1);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>embedding_size<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>embedding_desc.sizes[1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>embedding_stride<sp/>=<sp/>embedding_desc.stride;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>input_stride<sp/><sp/><sp/><sp/><sp/>=<sp/>temp_input_desc.stride;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>nvshmem_device_reference&lt;EmbeddingT&gt;<sp/>embedding_nvshmem_device_ref{embeding_nvshmem_ref};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(blockIdx.x<sp/>&gt;=<sp/>max_blocks_for_local)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>int64_t<sp/>thread_id<sp/>=<sp/>(blockIdx.x<sp/>-<sp/>max_blocks_for_local)<sp/>*<sp/>blockDim.x<sp/>+<sp/>threadIdx.x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int64_t<sp/>row_id<sp/>=<sp/>thread_id;<sp/>row_id<sp/>&lt;<sp/>indice_count<sp/>-<sp/>local_index_length;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>row_id<sp/>+=<sp/>(gridDim.x<sp/>-<sp/>max_blocks_for_local)<sp/>*<sp/>blockDim.x)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>int64_t<sp/>scaled_row_id<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>row_id<sp/>&lt;<sp/>local_index_start<sp/>?<sp/>row_id<sp/>:<sp/>row_id<sp/>+<sp/>local_index_length;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int64_t<sp/>embedding_table_idx<sp/>=<sp/>sorted_index[scaled_row_id];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>int64_t<sp/>input_idx<sp/><sp/><sp/><sp/><sp/>=<sp/>input_index[scaled_row_id];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(embedding_table_idx<sp/>&lt;<sp/>0)<sp/>continue;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>EmbeddingT*<sp/>temp_input_ptr<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>temp_input<sp/>+<sp/>input_stride<sp/>*<sp/>input_idx<sp/>+<sp/>temp_input_desc.storage_offset;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int64_t<sp/>embedding_offset<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>embedding_desc.storage_offset<sp/>+<sp/>embedding_table_idx<sp/>*<sp/>embedding_stride;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>dest_rank<sp/>=<sp/>embedding_nvshmem_device_ref.dest_rank(embedding_offset);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>EmbeddingT*<sp/>symmetric_address<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>embedding_nvshmem_device_ref.symmetric_address(embedding_offset);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(USE_IBGDA)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nvshmem_putmem((symmetric_address),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_cast&lt;const<sp/>EmbeddingT*&gt;(temp_input_ptr),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>embedding_size<sp/>*<sp/>sizeof(EmbeddingT),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dest_rank);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nvshmem_putmem_nbi((symmetric_address),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_cast&lt;const<sp/>EmbeddingT*&gt;(temp_input_ptr),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>embedding_size<sp/>*<sp/>sizeof(EmbeddingT),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dest_rank);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/>one<sp/>embedding<sp/>per<sp/>block</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>int<sp/>thread_id_in_group<sp/>=<sp/>threadIdx.x<sp/>%<sp/>threads_per_group;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>int<sp/>group_id_in_block<sp/><sp/>=<sp/>threadIdx.x<sp/>/<sp/>threads_per_group;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>int<sp/>groups_per_block<sp/><sp/><sp/>=<sp/>blockDim.x<sp/>/<sp/>threads_per_group;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>int<sp/>group_id<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>blockIdx.x<sp/>*<sp/>groups_per_block<sp/>+<sp/>group_id_in_block;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int64_t<sp/>row_id<sp/>=<sp/>local_index_start<sp/>+<sp/>group_id;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>row_id<sp/>&lt;<sp/>local_index_start<sp/>+<sp/>local_index_length;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>row_id<sp/>+=<sp/>max_blocks_for_local<sp/>*<sp/>groups_per_block)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>IndexT<sp/>embedding_table_idx<sp/>=<sp/>sorted_index[row_id];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>IndexT<sp/>input_idx<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>input_index[row_id];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(embedding_table_idx<sp/>&lt;<sp/>0)<sp/>continue;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>printf(&quot;*********in<sp/>kernel<sp/>:<sp/>idx_id<sp/>=%ld<sp/>,<sp/>embedding_table_idx:%ld,<sp/>output_idx:%ld</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>,\n&quot;,idx_id,<sp/>int64_t(embedding_table_idx),int64_t(<sp/>output_idx));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>EmbeddingT*<sp/>temp_input_ptr<sp/>=<sp/>temp_input<sp/>+<sp/>input_stride<sp/>*<sp/>input_idx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int64_t<sp/>embedding_offset<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>embedding_desc.storage_offset<sp/>+<sp/>embedding_table_idx<sp/>*<sp/>embedding_stride;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>EmbeddingT*<sp/>peer_embedding_ptr<sp/>=<sp/>static_cast&lt;EmbeddingT*&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nvshmem_ptr(embedding_nvshmem_device_ref.symmetric_address(embedding_offset),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>embedding_nvshmem_device_ref.dest_rank(embedding_offset)));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(peer_embedding_ptr<sp/>==<sp/>nullptr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;Error:<sp/>Could<sp/>not<sp/>find<sp/>peer<sp/>NVSHMEM<sp/>array.\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__trap();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>emb_idx<sp/>=<sp/>thread_id_in_group<sp/>*<sp/>ALIGNMENT;<sp/>emb_idx<sp/>&lt;<sp/>embedding_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>emb_idx<sp/>+=<sp/>ALIGNMENT<sp/>*<sp/>threads_per_group)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mov_data&lt;sizeof(EmbeddingT)<sp/>*<sp/>ALIGNMENT&gt;(peer_embedding_ptr<sp/>+<sp/>emb_idx,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>temp_input_ptr<sp/>+<sp/>emb_idx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>InputT,<sp/>typename<sp/>IndexT,<sp/>typename<sp/>EmbeddingT&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>nvshmem_scatter_temp_put_mem_sort_idx_func(wholememory_comm_t<sp/>wm_comm,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void*<sp/>input,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void*<sp/>temp_input,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t<sp/>input_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>void*<sp/>indices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int64_t<sp/>indice_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_nvshmem_ref_t<sp/>embeding_nvshmem_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t<sp/>embedding_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_t<sp/>embedding_entry_count_per_rank,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_env_func_t*<sp/>p_env_fns,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStream_t<sp/>stream,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>scatter_sms)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wm_thrust_allocator<sp/>thrust_allocator(p_env_fns);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(indice_count<sp/>==<sp/>0<sp/>||<sp/>embedding_desc.sizes[1]<sp/>==<sp/>0)<sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>temp_memory_handle<sp/>dev_raw_indice(p_env_fns);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexT*<sp/>dev_raw_indice_ptr<sp/>=<sp/>static_cast&lt;IndexT*&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dev_raw_indice.device_malloc(indice_count,<sp/>get_wholememory_dtype&lt;IndexT&gt;()));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>temp_memory_handle<sp/>dev_sorted_indice(p_env_fns);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void*<sp/>dev_sorted_indice_ptr<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>dev_sorted_indice.device_malloc(indice_count,<sp/>get_wholememory_dtype&lt;IndexT&gt;());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>sort_index_in_pair(indices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>indice_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dev_sorted_indice_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dev_raw_indice_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wm_comm,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;thrust_allocator,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stream);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>intra_node_rank_num<sp/>=<sp/>wm_comm-&gt;intra_node_rank_num;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>node_id<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>wm_comm-&gt;world_rank<sp/>/<sp/>wm_comm-&gt;intra_node_rank_num;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto<sp/>temp_input_data<sp/>=<sp/>static_cast&lt;EmbeddingT*&gt;(temp_input);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto<sp/>sorted_index<sp/><sp/><sp/><sp/>=<sp/>static_cast&lt;IndexT*&gt;(dev_sorted_indice_ptr);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_matrix_description_t<sp/>temp_input_desc<sp/>=<sp/>input_desc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>temp_input_desc.storage_offset<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>input_ele_size<sp/>=<sp/>wholememory_get_memory_element_count_from_matrix(&amp;input_desc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>constexpr<sp/>(sizeof(EmbeddingT)<sp/>==<sp/>sizeof(InputT))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>WM_CUDA_CHECK(cudaMemcpyAsync(temp_input,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static_cast&lt;InputT*&gt;(input)<sp/>+<sp/>input_desc.storage_offset,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>input_ele_size<sp/>*<sp/>sizeof(InputT),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMemcpyDeviceToDevice,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stream));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>embedding_output_convert_date_type_temp_func&lt;InputT,<sp/>EmbeddingT&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>static_cast&lt;EmbeddingT*&gt;(temp_input),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>static_cast&lt;InputT*&gt;(input),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>input_desc.sizes[0],</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>embedding_desc.sizes[1],</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>temp_input_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>input_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>stream);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>wm_alignment<sp/>=<sp/>determine_wholememory_alignment_elt_count(embedding_desc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>mm_alignment<sp/>=<sp/>determine_memory_alignment_elt_count(temp_input,<sp/>temp_input_desc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>alignment<sp/><sp/><sp/><sp/>=<sp/>std::min&lt;int&gt;(wm_alignment,<sp/>mm_alignment);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>char*<sp/>use_ibgda<sp/>=<sp/>std::getenv(&quot;NVSHMEM_IB_ENABLE_IBGDA&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>use_ibgda_flag<sp/><sp/><sp/>=<sp/>((use_ibgda<sp/>!=<sp/>nullptr)<sp/>&amp;&amp;<sp/>(strcmp(use_ibgda,<sp/>&quot;1&quot;)<sp/>==<sp/>0));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>(*scatter_nvshmem_kernel_fn)(EmbeddingT*,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_nvshmem_ref_t,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IndexT*,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IndexT*,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int64_t,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>int,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>int,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>int,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size_t,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>int)<sp/>=<sp/>nullptr;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>switch<sp/>(alignment)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>16:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>scatter_nvshmem_kernel_fn<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>use_ibgda_flag<sp/>?<sp/>scatter_func_with_nvshmem_sort_idxs_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>16,<sp/>true&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>scatter_func_with_nvshmem_sort_idxs_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>16,<sp/>false&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>8:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>scatter_nvshmem_kernel_fn<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>use_ibgda_flag<sp/>?<sp/>scatter_func_with_nvshmem_sort_idxs_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>8,<sp/>true&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>scatter_func_with_nvshmem_sort_idxs_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>8,<sp/>false&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>4:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>scatter_nvshmem_kernel_fn<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>use_ibgda_flag<sp/>?<sp/>scatter_func_with_nvshmem_sort_idxs_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>4,<sp/>true&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>scatter_func_with_nvshmem_sort_idxs_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>4,<sp/>false&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>2:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>scatter_nvshmem_kernel_fn<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>use_ibgda_flag<sp/>?<sp/>scatter_func_with_nvshmem_sort_idxs_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>2,<sp/>true&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>scatter_func_with_nvshmem_sort_idxs_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>2,<sp/>false&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>1:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>scatter_nvshmem_kernel_fn<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>use_ibgda_flag<sp/>?<sp/>scatter_func_with_nvshmem_sort_idxs_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>1,<sp/>true&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>scatter_func_with_nvshmem_sort_idxs_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>1,<sp/>false&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>default:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>WHOLEMEMORY_FAIL(&quot;gather<sp/>func<sp/>alignment=%d.&quot;,<sp/>alignment);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>block_threshold<sp/><sp/><sp/><sp/><sp/>=<sp/>64;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>max_blocks<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>1024;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>constexpr<sp/>int<sp/>WARP_SIZE<sp/>=<sp/>32;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>max_threads_per_block<sp/><sp/><sp/>=<sp/>256;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>num_threads_per_feature<sp/>=<sp/>std::min&lt;int64_t&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>max_threads_per_block,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>((embedding_desc.sizes[1]<sp/>/<sp/>alignment)<sp/>+<sp/>WARP_SIZE<sp/>-<sp/>1)<sp/>/<sp/>WARP_SIZE<sp/>*<sp/>WARP_SIZE);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>block_size<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(max_threads_per_block<sp/>/<sp/>num_threads_per_feature)<sp/>*<sp/>num_threads_per_feature;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>ngroup_per_block<sp/>=<sp/>block_size<sp/>/<sp/>num_threads_per_feature;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>num_blocks<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::min(max_blocks,<sp/>static_cast&lt;int&gt;(indice_count<sp/>+<sp/>ngroup_per_block)<sp/>/<sp/>ngroup_per_block);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>re-adjust<sp/>num_blocks/block_threshold<sp/>to<sp/>make<sp/>at<sp/>least<sp/>1<sp/>block<sp/>available<sp/>for<sp/>nvshmem<sp/>remote<sp/>get</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(num_blocks<sp/>&lt;<sp/>block_threshold)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>block_threshold<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(num_blocks<sp/>==<sp/>1)<sp/>num_blocks<sp/>=<sp/>2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>scatter_nvshmem_kernel_fn&lt;&lt;&lt;num_blocks,<sp/>block_size,<sp/>0,<sp/>stream&gt;&gt;&gt;(temp_input_data,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>temp_input_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>embeding_nvshmem_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>embedding_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sorted_index,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dev_raw_indice_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>indice_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block_threshold,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>intra_node_rank_num,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node_id,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>embedding_entry_count_per_rank,</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>num_threads_per_feature);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(!use_ibgda_flag)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>nvshmemx_quiet_on_stream(stream);<sp/><sp/>//<sp/>wait<sp/>transfer</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>WM_CUDA_CHECK(cudaGetLastError());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>(void)scatter_sms;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">};<sp/><sp/>//<sp/>namespace<sp/>wholememory_ops</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
    </programlisting>
    <location file="src/wholememory_ops/functions/nvshmem_gather_scatter_func.cuh"/>
  </compounddef>
</doxygen>
