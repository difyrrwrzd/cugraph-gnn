<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="embedding__cache__func_8cuh" kind="file" language="C++">
    <compoundname>embedding_cache_func.cuh</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">/*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Copyright<sp/>(c)<sp/>2019-2023,<sp/>NVIDIA<sp/>CORPORATION.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Licensed<sp/>under<sp/>the<sp/>Apache<sp/>License,<sp/>Version<sp/>2.0<sp/>(the<sp/>&quot;License&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>you<sp/>may<sp/>not<sp/>use<sp/>this<sp/>file<sp/>except<sp/>in<sp/>compliance<sp/>with<sp/>the<sp/>License.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>You<sp/>may<sp/>obtain<sp/>a<sp/>copy<sp/>of<sp/>the<sp/>License<sp/>at</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/>http://www.apache.org/licenses/LICENSE-2.0</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Unless<sp/>required<sp/>by<sp/>applicable<sp/>law<sp/>or<sp/>agreed<sp/>to<sp/>in<sp/>writing,<sp/>software</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>distributed<sp/>under<sp/>the<sp/>License<sp/>is<sp/>distributed<sp/>on<sp/>an<sp/>&quot;AS<sp/>IS&quot;<sp/>BASIS,</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>WITHOUT<sp/>WARRANTIES<sp/>OR<sp/>CONDITIONS<sp/>OF<sp/>ANY<sp/>KIND,<sp/>either<sp/>express<sp/>or<sp/>implied.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>See<sp/>the<sp/>License<sp/>for<sp/>the<sp/>specific<sp/>language<sp/>governing<sp/>permissions<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>limitations<sp/>under<sp/>the<sp/>License.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>once</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;cstdint&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;cuda.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;cuda_runtime_api.h&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;stdint.h&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;raft/matrix/detail/select_k-inl.cuh&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">namespace<sp/>wholememory_ops<sp/>{</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">__device__<sp/>__forceinline__<sp/>unsigned<sp/>int<sp/>WarpMatchLocalIDPairSync(int<sp/>targets,<sp/>int<sp/>key)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>xor_target<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>__shfl_xor_sync(0xFFFFFFFF,<sp/>targets,<sp/>0x10);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>first_half_lane<sp/>=<sp/>(threadIdx.x<sp/>&amp;<sp/>0x10)<sp/>==<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>match_value<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>unsigned<sp/>int<sp/>match_flag,<sp/>tmp_match_flag;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>match_value<sp/><sp/><sp/><sp/>=<sp/>first_half_lane<sp/>?<sp/>key<sp/>:<sp/>xor_target;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tmp_match_flag<sp/>=<sp/>__match_any_sync(0xFFFFFFFF,<sp/>match_value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(first_half_lane)<sp/>match_flag<sp/>=<sp/>tmp_match_flag<sp/>&gt;&gt;<sp/>16;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>match_value<sp/><sp/><sp/><sp/>=<sp/>first_half_lane<sp/>?<sp/>key<sp/>:<sp/>targets;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tmp_match_flag<sp/>=<sp/>__match_any_sync(0xFFFFFFFF,<sp/>match_value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(first_half_lane)<sp/>match_flag<sp/>|=<sp/>(tmp_match_flag<sp/>&amp;<sp/>0xFFFF0000);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>match_value<sp/><sp/><sp/><sp/>=<sp/>!first_half_lane<sp/>?<sp/>key<sp/>:<sp/>targets;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tmp_match_flag<sp/>=<sp/>__match_any_sync(0xFFFFFFFF,<sp/>match_value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(!first_half_lane)<sp/>match_flag<sp/>=<sp/>(tmp_match_flag<sp/>&amp;<sp/>0xFFFF);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>match_value<sp/><sp/><sp/><sp/>=<sp/>!first_half_lane<sp/>?<sp/>key<sp/>:<sp/>xor_target;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tmp_match_flag<sp/>=<sp/>__match_any_sync(0xFFFFFFFF,<sp/>match_value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(!first_half_lane)<sp/>match_flag<sp/>|=<sp/>(tmp_match_flag<sp/>&amp;<sp/>0xFFFF)<sp/>&lt;&lt;<sp/>16;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>match_flag;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">__device__<sp/>__forceinline__<sp/>int<sp/>WarpFindMaxScaleSync(int<sp/>scale)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal">#if<sp/>__CUDA_ARCH__<sp/>&gt;=<sp/>800</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>__reduce_max_sync(0xFFFFFFFF,<sp/>scale);</highlight></codeline>
<codeline><highlight class="normal">#else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>delta<sp/>=<sp/>16;<sp/>delta<sp/>&gt;<sp/>0;<sp/>delta<sp/>/=<sp/>2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>scale<sp/>=<sp/>max(__shfl_down_sync(0xFFFFFFFF,<sp/>scale,<sp/>delta,<sp/>32),<sp/>scale);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>__shfl_sync(0xFFFFFFFF,<sp/>scale,<sp/>0,<sp/>32);</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>CacheLineInfo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>CacheLineInfo()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>void<sp/>LoadTag(const<sp/>uint16_t*<sp/>tag_ptr)<sp/>{<sp/>tag_<sp/>=<sp/>tag_ptr[threadIdx.x];<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>void<sp/>LoadInfo(const<sp/>uint16_t*<sp/>tag_ptr,<sp/>const<sp/>uint16_t*<sp/>count_ptr)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tag_<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>tag_ptr[threadIdx.x];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lfu_count_<sp/>=<sp/>count_ptr[threadIdx.x];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>void<sp/>StoreTag(uint16_t*<sp/>tag_ptr)<sp/>const<sp/>{<sp/>tag_ptr[threadIdx.x]<sp/>=<sp/>tag_;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>void<sp/>StoreInfo(uint16_t*<sp/>tag_ptr,<sp/>uint16_t*<sp/>count_ptr)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>tag_ptr[threadIdx.x]<sp/><sp/><sp/>=<sp/>tag_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>count_ptr[threadIdx.x]<sp/>=<sp/>lfu_count_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>bool<sp/>IsValid()<sp/>const<sp/>{<sp/>return<sp/>(tag_<sp/>&amp;<sp/>kValidMask)<sp/>!=<sp/>0U;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>bool<sp/>IsInValid()<sp/>const<sp/>{<sp/>return<sp/>!IsValid();<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>bool<sp/>IsModified()<sp/>const<sp/>{<sp/>return<sp/>(tag_<sp/>&amp;<sp/>kModifiedMask)<sp/>!=<sp/>0U;<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>int<sp/>LocalID()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>IsValid()<sp/>?<sp/>(int)(tag_<sp/>&amp;<sp/>kLocalIDMask)<sp/>:<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>int<sp/>ScaleSync()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>__ballot_sync(0xFFFFFFFF,<sp/>lfu_count_<sp/>&amp;<sp/>kScaleMask);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>int64_t<sp/>LfuCountSync()<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>const<sp/>scale<sp/>=<sp/>ScaleSync();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int64_t<sp/>count<sp/><sp/><sp/>=<sp/>(lfu_count_<sp/>&amp;<sp/>kCountMask);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>count<sp/>&lt;&lt;=<sp/>scale;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>count<sp/>+=<sp/>(1ULL<sp/>&lt;&lt;<sp/>scale)<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Check<sp/>if<sp/>local_id<sp/>is<sp/>in<sp/>CacheSet</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>@param<sp/>local_id<sp/>:<sp/>local_id</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>@return<sp/>:<sp/>CacheLine<sp/>Id<sp/>if<sp/>key<sp/>in<sp/>cache,<sp/>else<sp/>-1.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>int<sp/>KeyIndexSync(int<sp/>local_id)<sp/>const</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>is_key_in_cache_line<sp/>=<sp/>IsValid()<sp/>&amp;&amp;<sp/>LocalID()<sp/>==<sp/>local_id;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>mask<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>__ballot_sync(0xFFFFFFFF,<sp/>static_cast&lt;int&gt;(is_key_in_cache_line));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>__ffs(0)<sp/>returns<sp/>0</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>__ffs(mask)<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Set<sp/>new<sp/>counter<sp/>for<sp/>LFU,<sp/>if<sp/>invalid,<sp/>use<sp/>-1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>@param<sp/>new_lfu_count<sp/>:<sp/>new<sp/>LFU<sp/>count</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>void<sp/>SetScaleLfuCountSync(int64_t<sp/>new_lfu_count)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>scale<sp/><sp/><sp/><sp/><sp/>=<sp/>(new_lfu_count<sp/>&gt;=<sp/>0)<sp/>?<sp/>64<sp/>-<sp/>__clzll(new_lfu_count)<sp/>:<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>scale<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>max(scale,<sp/>kScaledCounterBits)<sp/>-<sp/>kScaledCounterBits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>max_scale<sp/>=<sp/>WarpFindMaxScaleSync(scale);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>printf(&quot;threadIdx.x=%d,<sp/>new_lfu_count=%ld,<sp/>scale=%d,<sp/>max_scale=%d\n&quot;,<sp/>threadIdx.x,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>new_lfu_count,<sp/>scale,<sp/>max_scale);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>scale_lfu_count<sp/>=<sp/>new_lfu_count<sp/>&gt;&gt;<sp/>max_scale;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>scale_lfu_count<sp/>|=<sp/>((max_scale<sp/>&gt;&gt;<sp/>threadIdx.x)<sp/>&amp;<sp/>1)<sp/>&lt;&lt;<sp/>kScaledCounterBits;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lfu_count_<sp/>=<sp/>scale_lfu_count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>void<sp/>SetLocalID(int<sp/>local_id)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(local_id<sp/>&gt;=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(IsInValid()<sp/>||<sp/>local_id<sp/>!=<sp/>LocalID())<sp/>ClearModify();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>tag_<sp/>&amp;=<sp/>~(kLocalIDMask<sp/>|<sp/>kValidMask);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>tag_<sp/>|=<sp/>(local_id<sp/>|<sp/>kValidMask);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>tag_<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>void<sp/>SetModified(int<sp/>local_id)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(local_id<sp/>&gt;=<sp/>0<sp/>&amp;&amp;<sp/>local_id<sp/>==<sp/>LocalID())<sp/>{<sp/>tag_<sp/>|=<sp/>kModifiedMask;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>void<sp/>ClearCacheLine()<sp/>{<sp/>tag_<sp/>=<sp/>0;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>void<sp/>ClearModify()<sp/>{<sp/>tag_<sp/>&amp;=<sp/>~kModifiedMask;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>constexpr<sp/>int<sp/>kCacheSetSize<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>32;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>constexpr<sp/>int<sp/>kLocalIDBits<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>14;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>constexpr<sp/>int<sp/>kScaledCounterBits<sp/>=<sp/>14;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>constexpr<sp/>uint32_t<sp/>kValidMask<sp/><sp/><sp/><sp/>=<sp/>(1U<sp/>&lt;&lt;<sp/>14);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>constexpr<sp/>uint32_t<sp/>kModifiedMask<sp/>=<sp/>(1U<sp/>&lt;&lt;<sp/>15);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>constexpr<sp/>uint32_t<sp/>kLocalIDMask<sp/><sp/>=<sp/>(1U<sp/>&lt;&lt;<sp/>14)<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>constexpr<sp/>uint32_t<sp/>kCountMask<sp/><sp/><sp/><sp/>=<sp/>(1U<sp/>&lt;&lt;<sp/>14)<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>constexpr<sp/>uint32_t<sp/>kScaleMask<sp/><sp/><sp/><sp/>=<sp/>(1U<sp/>&lt;&lt;<sp/>14);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>uint32_t<sp/>tag_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>uint32_t<sp/>lfu_count_;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>NodeIDT&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>CacheSetUpdater<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>constexpr<sp/>int<sp/>kTopKRegisterCount<sp/>=<sp/>4;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>constexpr<sp/>int<sp/>kCacheSetSize<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>CacheLineInfo::kCacheSetSize;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>constexpr<sp/>int<sp/>kScaledCounterBits<sp/>=<sp/>14;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>warp_bq_t<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>raft::matrix::detail::select::warpsort::warp_sort_immediate&lt;kCacheSetSize,<sp/>false,<sp/>int64_t,<sp/>int&gt;;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>constexpr<sp/>int<sp/>WARP_SIZE<sp/><sp/>=<sp/>32;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>constexpr<sp/>int<sp/>BLOCK_SIZE<sp/>=<sp/>kCacheSetSize;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static_assert(kCacheSetSize<sp/>==<sp/>WARP_SIZE,<sp/>&quot;only<sp/>support<sp/>CacheSetSize==32,and<sp/>BLOCK_SIZE==32\n&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>struct<sp/>TempStorage<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int64_t<sp/>store_keys[kCacheSetSize];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>store_values[kCacheSetSize];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>From<sp/>all<sp/>invalid<sp/>CacheSet,<sp/>recompute<sp/>lids<sp/>to<sp/>cache,<sp/>and<sp/>update<sp/>cache_line_info.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>NOTE:<sp/>data<sp/>are<sp/>not<sp/>loaded,<sp/>need<sp/>to<sp/>load<sp/>after<sp/>this<sp/>function</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>@param<sp/>temp_storage<sp/>:<sp/>temp_storage</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>@param<sp/>cache_line_info<sp/>:<sp/>cache_line_info,<sp/>will<sp/>be<sp/>updated.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>@param<sp/>memory_lfu_counter<sp/>:<sp/>lfu_counter<sp/>in<sp/>memory<sp/>of<sp/>this<sp/>cache<sp/>set</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>@param<sp/>id_count<sp/>:<sp/>valid<sp/>count<sp/>in<sp/>this<sp/>cache<sp/>set,<sp/>most<sp/>cases<sp/>it<sp/>is<sp/>cache_set_coverage,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>maybe<sp/>smaller<sp/>than<sp/>kCacheSetSize<sp/>tailing<sp/>cache<sp/>set.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>void<sp/>ReComputeCache(TempStorage&amp;<sp/>temp_storage,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CacheLineInfo&amp;<sp/>cache_line_info,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int64_t*<sp/>memory_lfu_counter,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>id_count)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(id_count<sp/>&lt;=<sp/>0)<sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>assert(cache_line_info.IsInValid());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>int<sp/>base_idx<sp/><sp/><sp/><sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>int<sp/>valid_count<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>FillCandidate&lt;false&gt;(nullptr,<sp/>nullptr,<sp/>memory_lfu_counter,<sp/>0,<sp/>id_count,<sp/>temp_storage,<sp/>-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cache_line_info.ClearCacheLine();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cache_line_info.SetLocalID(candidate_local_id_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cache_line_info.SetScaleLfuCountSync(candidate_local_id_<sp/>&gt;=<sp/>0<sp/>?<sp/>candidate_lfu_count_<sp/>:<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Update<sp/>cache<sp/>set<sp/>according<sp/>to<sp/>gids<sp/>and<sp/>inc_count</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>@tparam<sp/>NeedOutputLoadIDs<sp/>:<sp/>If<sp/>need<sp/>to<sp/>output<sp/>IDs<sp/>that<sp/>should<sp/>be<sp/>loaded<sp/>into<sp/>cache</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>@tparam<sp/>NeedOutputWriteBackIDs<sp/>:<sp/>If<sp/>need<sp/>to<sp/>output<sp/>IDs<sp/>that<sp/>should<sp/>be<sp/>write<sp/>back<sp/>to<sp/>memory</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>@param<sp/>temp_storage<sp/>:<sp/>Work<sp/>space<sp/>storage</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>@param<sp/>cache_line_info<sp/>:<sp/>cache<sp/>line<sp/>info<sp/>that<sp/>already<sp/>loaded,<sp/>will<sp/>be<sp/>updated</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>@param<sp/>memory_lfu_counter<sp/>:<sp/>counter<sp/>pointer<sp/>of<sp/>IDs<sp/>that<sp/>current<sp/>cache<sp/>set<sp/>covers.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>@param<sp/>gids<sp/>:<sp/>GIDs<sp/>to<sp/>update</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>@param<sp/>inc_count<sp/>:<sp/>same<sp/>length<sp/>as<sp/>gids,<sp/>the<sp/>count<sp/>of<sp/>each<sp/>GIDs<sp/>to<sp/>added,<sp/>if<sp/>nullptr,<sp/>each<sp/>GID</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>add<sp/>1.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>@param<sp/>need_load_to_cache_ids<sp/>:<sp/>output<sp/>of<sp/>IDs<sp/>that<sp/>should<sp/>be<sp/>loaded<sp/>into<sp/>cache,<sp/>if<sp/>not<sp/>needed,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>use<sp/>nullptr</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>@param<sp/>need_write_back_ids<sp/>:<sp/>output<sp/>of<sp/>IDs<sp/>that<sp/>should<sp/>be<sp/>write<sp/>back<sp/>to<sp/>memory,<sp/>if<sp/>not<sp/>needed,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>use<sp/>nullptr</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>@param<sp/>set_start_id<sp/>:<sp/>start<sp/>GID<sp/>of<sp/>current<sp/>cache<sp/>set</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>@param<sp/>id_count<sp/>:<sp/>count<sp/>of<sp/>GIDs</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template<sp/>&lt;bool<sp/>NeedOutputLoadIDs,<sp/>bool<sp/>NeedOutputWriteBackIDs&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>void<sp/>UpdateCache(TempStorage&amp;<sp/>temp_storage,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CacheLineInfo&amp;<sp/>cache_line_info,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int64_t*<sp/>memory_lfu_counter,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>NodeIDT*<sp/>gids,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>int*<sp/>inc_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>NodeIDT*<sp/>need_load_to_cache_ids,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>NodeIDT*<sp/>need_write_back_ids,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int64_t<sp/>set_start_id,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>id_count)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(id_count<sp/>&lt;=<sp/>0)<sp/>return;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>candidate_lfu_count_<sp/><sp/><sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>candidate_local_id_<sp/><sp/><sp/><sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>cached_local_id<sp/><sp/><sp/><sp/>=<sp/>cache_line_info.LocalID();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>has_local_id_count<sp/>=<sp/>FillCandidate(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>gids,<sp/>inc_count,<sp/>memory_lfu_counter,<sp/>set_start_id,<sp/>id_count,<sp/>temp_storage,<sp/>cached_local_id);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>printf(&quot;[TopK<sp/>init<sp/>dump]<sp/>threadIdx.x=%d,<sp/>lfu_count=%ld,<sp/>lid=%d,<sp/>has_local_id_count<sp/>=<sp/>%d<sp/>\n&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>threadIdx.x,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>candidate_lfu_count_,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>candidate_local_id_,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>has_local_id_count);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int64_t<sp/>candidate_lfu_count0<sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>candidate_local_id0<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>match_flag;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>match_flag<sp/>=<sp/>WarpMatchLocalIDPairSync(candidate_local_id_[0],<sp/>cached_local_id);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int64_t<sp/>estimated_lfu_count<sp/>=<sp/>cache_line_info.LfuCountSync();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Valid<sp/>AND<sp/>NOT<sp/>exist<sp/>in<sp/>update<sp/>list</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(cached_local_id<sp/>!=<sp/>-1<sp/>&amp;&amp;<sp/>has_local_id_count<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>cached<sp/>key<sp/>not<sp/>updated,<sp/>use<sp/>estimated<sp/>lfu_count<sp/>from<sp/>cache</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>candidate_lfu_count0<sp/>=<sp/>estimated_lfu_count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>candidate_local_id0<sp/><sp/>=<sp/>cached_local_id;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>warp_bq_t<sp/>warp_queue(kCacheSetSize);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>warp_queue.add(candidate_lfu_count_,<sp/>candidate_local_id_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>warp_queue.add(candidate_lfu_count0,<sp/>candidate_local_id0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>warp_queue.done();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>warp_queue.store(temp_storage.store_keys,<sp/>temp_storage.store_values);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>__syncthreads();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(threadIdx.x<sp/>&lt;<sp/>kCacheSetSize)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>candidate_lfu_count_<sp/>=<sp/>temp_storage.store_keys[threadIdx.x];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>candidate_local_id_<sp/><sp/>=<sp/>temp_storage.store_values[threadIdx.x];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>printf(&quot;[TopK<sp/>merge<sp/>dump]<sp/>threadIdx.x=%d,<sp/>lfu_count=%ld,<sp/>lid=%d\n&quot;,<sp/>threadIdx.x,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>candidate_lfu_count_[0],<sp/>candidate_local_id_[0]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>match_flag<sp/><sp/><sp/><sp/><sp/>=<sp/>WarpMatchLocalIDPairSync(candidate_local_id_,<sp/>cached_local_id);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>from_lane<sp/><sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>has_match<sp/>=<sp/>(cached_local_id<sp/>&gt;=<sp/>0<sp/>&amp;&amp;<sp/>match_flag<sp/>!=<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(has_match)<sp/>from_lane<sp/>=<sp/>__ffs(match_flag)<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>can_update_mask<sp/><sp/><sp/>=<sp/>__ballot_sync(0xFFFFFFFF,<sp/>!has_match);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>lower_thread_mask<sp/>=<sp/>(1U<sp/>&lt;&lt;<sp/>threadIdx.x)<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>updatable_cache_line_rank<sp/><sp/>=<sp/>!has_match<sp/>?<sp/>__popc(can_update_mask<sp/>&amp;<sp/>lower_thread_mask)<sp/>:<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>new_match_flag<sp/><sp/><sp/><sp/>=<sp/>WarpMatchLocalIDPairSync(cached_local_id,<sp/>candidate_local_id_);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>printf(&quot;tid=%d,<sp/>cached_local_id=%d,<sp/>candidate_local_id_=%d,<sp/>new_match_flag=%x\n&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>threadIdx.x,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cached_local_id,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>candidate_local_id_,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_match_flag);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>new_need_slot<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>(candidate_local_id_<sp/>&gt;=<sp/>0<sp/>&amp;&amp;<sp/>new_match_flag<sp/>==<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>need_new_slot_mask<sp/>=<sp/>__ballot_sync(0xFFFFFFFF,<sp/>new_need_slot);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>insert_data_rank<sp/>=<sp/>new_need_slot<sp/>?<sp/>__popc(need_new_slot_mask<sp/>&amp;<sp/>lower_thread_mask)<sp/>:<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>printf(&quot;tid=%d,<sp/>updatable_cache_line_rank=%d,<sp/>insert_data_rank=%d\n&quot;,<sp/>threadIdx.x,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>updatable_cache_line_rank,<sp/>insert_data_rank);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>rank_match_flag<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>WarpMatchLocalIDPairSync(insert_data_rank,<sp/>updatable_cache_line_rank);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(updatable_cache_line_rank<sp/>!=<sp/>-1<sp/>&amp;&amp;<sp/>rank_match_flag<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>from_lane<sp/>=<sp/>__ffs(rank_match_flag)<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>src_lane_idx<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>from_lane<sp/>&gt;=<sp/>0<sp/>?<sp/>from_lane<sp/>:<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int64_t<sp/>new_lfu_count<sp/>=<sp/>__shfl_sync(0xFFFFFFFF,<sp/>candidate_lfu_count_,<sp/>src_lane_idx,<sp/>32);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>new_local_id<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>__shfl_sync(0xFFFFFFFF,<sp/>candidate_local_id_,<sp/>src_lane_idx,<sp/>32);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(from_lane<sp/>==<sp/>-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>new_local_id<sp/><sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>new_lfu_count<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>printf(&quot;tid=%d,<sp/>new_local_id=%d,<sp/>new_lfu_count=%ld\n&quot;,<sp/>threadIdx.x,<sp/>new_local_id,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>new_lfu_count);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(NeedOutputLoadIDs<sp/>&amp;&amp;<sp/>need_load_to_cache_ids<sp/>!=<sp/>nullptr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>new_cached_lid<sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(new_need_slot)<sp/>{<sp/>new_cached_lid<sp/>=<sp/>candidate_local_id_;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>load_cache_mask<sp/>=<sp/>__ballot_sync(0xFFFFFFFF,<sp/>new_cached_lid<sp/>&gt;=<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>output_idx<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>__popc(load_cache_mask<sp/>&amp;<sp/>((1<sp/>&lt;&lt;<sp/>threadIdx.x)<sp/>-<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>total_load_count<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>__popc(load_cache_mask);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(new_need_slot)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>need_load_to_cache_ids[output_idx]<sp/>=<sp/>new_cached_lid<sp/>+<sp/>set_start_id;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>printf(&quot;tid=%d,<sp/>load_cache_mask=%x,<sp/>NeedLoadGIDs[%d]=%ld\n&quot;,<sp/>threadIdx.x,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>load_cache_mask,<sp/>output_idx,<sp/>new_cached_lid<sp/>+<sp/>set_start_id);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(threadIdx.x<sp/>&gt;=<sp/>total_load_count<sp/>&amp;&amp;<sp/>threadIdx.x<sp/>&lt;<sp/>min(id_count,<sp/>kCacheSetSize))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>need_load_to_cache_ids[threadIdx.x]<sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(NeedOutputWriteBackIDs<sp/>&amp;&amp;<sp/>need_write_back_ids<sp/>!=<sp/>nullptr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>write_back_lid<sp/><sp/><sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>need_write_back<sp/>=<sp/>cached_local_id<sp/>&gt;=<sp/>0<sp/>&amp;&amp;<sp/>!has_match<sp/>&amp;&amp;<sp/>cache_line_info.IsModified();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(need_write_back)<sp/>{<sp/>write_back_lid<sp/>=<sp/>cache_line_info.LocalID();<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>write_back_mask<sp/>=<sp/>__ballot_sync(0xFFFFFFFF,<sp/>write_back_lid<sp/>&gt;=<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>output_idx<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>__popc(write_back_mask<sp/>&amp;<sp/>((1<sp/>&lt;&lt;<sp/>threadIdx.x)<sp/>-<sp/>1));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(need_write_back)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>need_write_back_ids[output_idx]<sp/>=<sp/>write_back_lid<sp/>+<sp/>set_start_id;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>printf(&quot;tid=%d,<sp/>WriteBackGIDs[%d]=%ld\n&quot;,<sp/>threadIdx.x,<sp/>output_idx,<sp/>write_back_lid<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>set_start_id);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>total_write_back_count<sp/>=<sp/>__popc(write_back_mask);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(threadIdx.x<sp/>&gt;=<sp/>total_write_back_count<sp/>&amp;&amp;<sp/>threadIdx.x<sp/>&lt;<sp/>min(id_count,<sp/>kCacheSetSize))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>need_write_back_ids[threadIdx.x]<sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cache_line_info.SetScaleLfuCountSync(new_lfu_count);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cache_line_info.SetLocalID(new_local_id);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>candidate_lfu_count_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>candidate_local_id_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template<sp/>&lt;bool<sp/>IncCounter<sp/>=<sp/>true&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>int<sp/>FillCandidate(const<sp/>NodeIDT*<sp/>gids,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>int*<sp/>inc_freq_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int64_t*<sp/>cache_set_coverage_counter,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int64_t<sp/>cache_set_start_id,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>id_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TempStorage&amp;<sp/>temp_storage,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>cached_local_id)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>warp_bq_t<sp/>warp_queue(kCacheSetSize);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>int<sp/>per_thread_lim<sp/>=<sp/>id_count<sp/>+<sp/>raft::laneId();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>has_local_id_count<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>idx<sp/>=<sp/>threadIdx.x;<sp/>idx<sp/>&lt;<sp/>per_thread_lim;<sp/>idx<sp/>+=<sp/>BLOCK_SIZE)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>local_id<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int64_t<sp/>candidate_lfu_count<sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>candidate_local_id<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(idx<sp/>&lt;<sp/>id_count)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>local_id<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>gids<sp/>!=<sp/>nullptr<sp/>?<sp/>gids[idx]<sp/>-<sp/>cache_set_start_id<sp/>:<sp/>idx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>candidate_lfu_count<sp/>=<sp/>cache_set_coverage_counter[local_id];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(IncCounter)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>id_inc_count<sp/>=<sp/>inc_freq_count<sp/>!=<sp/>nullptr<sp/>?<sp/>inc_freq_count[idx]<sp/>:<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>candidate_lfu_count<sp/>+=<sp/>id_inc_count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cache_set_coverage_counter[local_id]<sp/>=<sp/>candidate_lfu_count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>candidate_local_id<sp/>=<sp/>local_id;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>local_id_match_mask<sp/>=<sp/>WarpMatchLocalIDPairSync(local_id,<sp/>cached_local_id);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>has_local_id_count<sp/>+=<sp/>((cached_local_id<sp/>!=<sp/>-1)<sp/>?<sp/>__popc(local_id_match_mask)<sp/>:<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>warp_queue.add(candidate_lfu_count,<sp/>candidate_local_id);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>warp_queue.done();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>warp_queue.store(temp_storage.store_keys,<sp/>temp_storage.store_values);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>__syncthreads();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(threadIdx.x<sp/>&lt;<sp/>kCacheSetSize)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>candidate_lfu_count_<sp/>=<sp/>temp_storage.store_keys[threadIdx.x];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>candidate_local_id_<sp/><sp/>=<sp/>temp_storage.store_values[threadIdx.x];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>__syncthreads();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>has_local_id_count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">}<sp/><sp/>//<sp/>namespace<sp/>wholememory_ops</highlight></codeline>
    </programlisting>
    <location file="src/wholememory_ops/functions/embedding_cache_func.cuh"/>
  </compounddef>
</doxygen>
