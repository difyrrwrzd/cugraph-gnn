<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="append__unique__func_8cuh" kind="file" language="C++">
    <compoundname>append_unique_func.cuh</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">/*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Copyright<sp/>(c)<sp/>2019-2024,<sp/>NVIDIA<sp/>CORPORATION.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Licensed<sp/>under<sp/>the<sp/>Apache<sp/>License,<sp/>Version<sp/>2.0<sp/>(the<sp/>&quot;License&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>you<sp/>may<sp/>not<sp/>use<sp/>this<sp/>file<sp/>except<sp/>in<sp/>compliance<sp/>with<sp/>the<sp/>License.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>You<sp/>may<sp/>obtain<sp/>a<sp/>copy<sp/>of<sp/>the<sp/>License<sp/>at</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/>http://www.apache.org/licenses/LICENSE-2.0</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Unless<sp/>required<sp/>by<sp/>applicable<sp/>law<sp/>or<sp/>agreed<sp/>to<sp/>in<sp/>writing,<sp/>software</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>distributed<sp/>under<sp/>the<sp/>License<sp/>is<sp/>distributed<sp/>on<sp/>an<sp/>&quot;AS<sp/>IS&quot;<sp/>BASIS,</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>WITHOUT<sp/>WARRANTIES<sp/>OR<sp/>CONDITIONS<sp/>OF<sp/>ANY<sp/>KIND,<sp/>either<sp/>express<sp/>or<sp/>implied.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>See<sp/>the<sp/>License<sp/>for<sp/>the<sp/>specific<sp/>language<sp/>governing<sp/>permissions<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>limitations<sp/>under<sp/>the<sp/>License.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>once</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;cuda_macros.hpp&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;error.hpp&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;wholememory_ops/output_memory_handle.hpp&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;wholememory_ops/temp_memory_handle.hpp&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;wholememory_ops/thrust_allocator.hpp&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;cooperative_groups.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;raft/util/integer_utils.hpp&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;thrust/scan.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;wholememory/env_func_ptrs.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;wholememory/tensor_description.h&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">namespace<sp/>graph_ops<sp/>{</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">static<sp/>constexpr<sp/>int<sp/>kAssignBucketSize<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>32;<sp/><sp/>//<sp/>it<sp/>is<sp/>not<sp/>adjustable</highlight></codeline>
<codeline><highlight class="normal">static<sp/>constexpr<sp/>int<sp/>kAssignThreadBlockSize<sp/>=<sp/>8<sp/>*<sp/>32;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>KeyT,<sp/>int<sp/>BucketSize&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>AppendUniqueHash;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>KeyT,<sp/>int<sp/>BucketSize,<sp/>bool<sp/>IsTarget<sp/>=<sp/>true&gt;</highlight></codeline>
<codeline><highlight class="normal">__global__<sp/>void<sp/>InsertKeysKernel(AppendUniqueHash&lt;KeyT,<sp/>BucketSize&gt;<sp/>auh);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>KeyT,<sp/>int<sp/>BucketSize,<sp/>bool<sp/>IsTarget<sp/>=<sp/>false&gt;</highlight></codeline>
<codeline><highlight class="normal">__global__<sp/>void<sp/>RetrieveKeysKernel(AppendUniqueHash&lt;KeyT,<sp/>BucketSize&gt;<sp/>auh,<sp/>int*<sp/>output);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal">__device__<sp/>__forceinline__<sp/>T<sp/>atomicCASSigned(T*<sp/>ptr,<sp/>T<sp/>cmp,<sp/>T<sp/>val)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>atomicCAS(ptr,<sp/>cmp,<sp/>val);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">__device__<sp/>__forceinline__<sp/>int64_t<sp/>atomicCASSigned&lt;int64_t&gt;(int64_t*<sp/>ptr,<sp/>int64_t<sp/>cmp,<sp/>int64_t<sp/>val)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>(int64_t)atomicCAS((unsigned<sp/>long<sp/>long*)ptr,<sp/>cmp,<sp/>val);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>KeyT,<sp/>int<sp/>BucketSize<sp/>=<sp/>kAssignBucketSize<sp/>/<sp/>sizeof(KeyT)&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>AppendUniqueHash<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AppendUniqueHash(int<sp/>target_count,<sp/>int<sp/>neighbor_count,<sp/>const<sp/>KeyT*<sp/>targets,<sp/>const<sp/>KeyT*<sp/>neighbors)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>target_count_(target_count),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>neighbor_count_(neighbor_count),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>targets_(targets),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>neighbors_(neighbors)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>total_slots_needed<sp/>=<sp/>(target_count<sp/>+<sp/>neighbor_count)<sp/>*<sp/>2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>total_slots_needed<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>raft::div_rounding_up_safe&lt;int&gt;(total_slots_needed,<sp/>kAssignBucketSize)<sp/>*<sp/>kAssignBucketSize;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bucket_count_<sp/>=<sp/>raft::div_rounding_up_safe&lt;int&gt;(total_slots_needed,<sp/>BucketSize)<sp/>+<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>~AppendUniqueHash()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>AllocateMemoryAndInit(wholememory_ops::temp_memory_handle&amp;<sp/>hash_teable_keys_tmh,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_ops::temp_memory_handle&amp;<sp/>hash_teable_values_tmh,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStream_t<sp/>stream)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>compute<sp/>bucket_count_<sp/>and<sp/>allocate<sp/>memory.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>total_alloc_slots<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>raft::div_rounding_up_safe&lt;int&gt;(bucket_count_<sp/>*<sp/>BucketSize,<sp/>kAssignThreadBlockSize)<sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>kAssignThreadBlockSize;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>wholememory_dtype_t<sp/>table_key_wholememory_dtype<sp/>=<sp/>WHOLEMEMORY_DT_INT;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(sizeof(KeyT)<sp/>==<sp/>8)<sp/>{<sp/>table_key_wholememory_dtype<sp/>=<sp/>WHOLEMEMORY_DT_INT64;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>table_keys_<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>(KeyT*)hash_teable_keys_tmh.device_malloc(total_alloc_slots,<sp/>table_key_wholememory_dtype);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>value_id_<sp/>=<sp/>(int*)hash_teable_values_tmh.device_malloc(total_alloc_slots,<sp/>WHOLEMEMORY_DT_INT);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>init<sp/>key<sp/>to<sp/>-1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>WM_CUDA_CHECK(cudaMemsetAsync(table_keys_,<sp/>-1,<sp/>total_alloc_slots<sp/>*<sp/>sizeof(KeyT),<sp/>stream));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>init<sp/>value_id<sp/>to<sp/>-1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>WM_CUDA_CHECK(cudaMemsetAsync(value_id_,<sp/>-1,<sp/>total_alloc_slots<sp/>*<sp/>sizeof(int),<sp/>stream));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>InsertKeys(cudaStream_t<sp/>stream)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>int<sp/>thread_count<sp/>=<sp/>512;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>target_block_count<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>raft::div_rounding_up_safe&lt;int&gt;(target_count_<sp/>*<sp/>BucketSize,<sp/>thread_count);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>InsertKeysKernel&lt;KeyT,<sp/>BucketSize,<sp/>true&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;&lt;target_block_count,<sp/>thread_count,<sp/>0,<sp/>stream&gt;&gt;&gt;(*this);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>WM_CUDA_CHECK(cudaStreamSynchronize(stream));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>neighbor_block_count<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>raft::div_rounding_up_safe&lt;int&gt;(neighbor_count_<sp/>*<sp/>BucketSize,<sp/>thread_count);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>InsertKeysKernel&lt;KeyT,<sp/>BucketSize,<sp/>false&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;&lt;neighbor_block_count,<sp/>thread_count,<sp/>0,<sp/>stream&gt;&gt;&gt;(*this);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>RetrieveNeighborKeysForValueIDs(cudaStream_t<sp/>stream,<sp/>int*<sp/>value_ids)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>int<sp/>thread_count<sp/>=<sp/>512;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>target_block_count<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>raft::div_rounding_up_safe&lt;int&gt;(neighbor_count_<sp/>*<sp/>BucketSize,<sp/>thread_count);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>RetrieveKeysKernel&lt;KeyT,<sp/>BucketSize&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;&lt;target_block_count,<sp/>thread_count,<sp/>0,<sp/>stream&gt;&gt;&gt;(*this,<sp/>value_ids);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__host__<sp/>__device__<sp/>__forceinline__<sp/>int<sp/>TargetCount()<sp/>{<sp/>return<sp/>target_count_;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__host__<sp/>__device__<sp/>__forceinline__<sp/>int<sp/>NeighborCount()<sp/>{<sp/>return<sp/>neighbor_count_;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__host__<sp/>__device__<sp/>__forceinline__<sp/>const<sp/>KeyT*<sp/>Targets()<sp/>{<sp/>return<sp/>targets_;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__host__<sp/>__device__<sp/>__forceinline__<sp/>const<sp/>KeyT*<sp/>Neighbors()<sp/>{<sp/>return<sp/>neighbors_;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__host__<sp/>__device__<sp/>__forceinline__<sp/>KeyT*<sp/>TableKeys()<sp/>{<sp/>return<sp/>table_keys_;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__host__<sp/>__device__<sp/>__forceinline__<sp/>int32_t*<sp/>ValueID()<sp/>{<sp/>return<sp/>value_id_;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>size_t<sp/>SlotCount()<sp/>{<sp/>return<sp/>bucket_count_<sp/>*<sp/>BucketSize;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>GetBucketLayout(int*<sp/>bucket_count,<sp/>int*<sp/>bucket_size)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*bucket_count<sp/>=<sp/>bucket_count_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*bucket_size<sp/><sp/>=<sp/>BucketSize;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>constexpr<sp/>KeyT<sp/>kInvalidKey<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>-1LL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>constexpr<sp/>int<sp/>kInvalidValueID<sp/><sp/><sp/><sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>constexpr<sp/>int<sp/>kNeedAssignValueID<sp/>=<sp/>-2;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>int<sp/>retrieve_key(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>KeyT&amp;<sp/>key,<sp/>cooperative_groups::thread_block_tile&lt;BucketSize&gt;&amp;<sp/>group)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>On<sp/>find,<sp/>return<sp/>global<sp/>slot<sp/>offset</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>On<sp/>not<sp/>find,<sp/>return<sp/>new<sp/>slot<sp/>and<sp/>set<sp/>key.<sp/>Not<sp/>find<sp/>and<sp/>don&apos;t<sp/>need<sp/>new</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>slot<sp/>case<sp/>should<sp/>not<sp/>happen.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>base_bucket_id<sp/>=<sp/>bucket_for_key(key);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>bucket_id;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>local_slot_offset<sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>try_idx<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>do<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>bucket_id<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>bucket_id_on_conflict(base_bucket_id,<sp/>try_idx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>local_slot_offset<sp/>=<sp/>key_in_bucket(key,<sp/>bucket_id,<sp/>group);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>try_idx++;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>while<sp/>(local_slot_offset<sp/>&lt;<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>bucket_id<sp/>*<sp/>BucketSize<sp/>+<sp/>local_slot_offset;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>void<sp/>insert_key(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>KeyT&amp;<sp/>key,<sp/>const<sp/>int<sp/>id,<sp/>cooperative_groups::thread_block_tile&lt;BucketSize&gt;&amp;<sp/>group)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>slot_offset<sp/><sp/><sp/>=<sp/>retrieve_key(key,<sp/>group);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int*<sp/>value_id_ptr<sp/>=<sp/>value_id_<sp/>+<sp/>slot_offset;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(group.thread_rank()<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(id<sp/>==<sp/>kNeedAssignValueID)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>neighbor</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>atomicCAS(value_id_ptr,<sp/>kInvalidValueID,<sp/>id);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>target</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*value_id_ptr<sp/>=<sp/>id;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>int<sp/>bucket_for_key(const<sp/>KeyT&amp;<sp/>key)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>uint32_t<sp/>hash_value<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>((uint32_t)((uint64_t)key<sp/>&gt;&gt;<sp/>32ULL))<sp/>*<sp/>0x85ebca6b<sp/>+<sp/>(uint32_t)((uint64_t)key<sp/>&amp;<sp/>0xFFFFFFFFULL);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>hash_value<sp/>%<sp/>bucket_count_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>int<sp/>bucket_id_on_conflict(int<sp/>base_bucket_id,<sp/>int<sp/>try_idx)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>(base_bucket_id<sp/>+<sp/>try_idx<sp/>*<sp/>try_idx)<sp/>%<sp/>bucket_count_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__device__<sp/>__forceinline__<sp/>int<sp/>key_in_bucket(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>KeyT&amp;<sp/>key,<sp/>int<sp/>bucket_id,<sp/>cooperative_groups::thread_block_tile&lt;BucketSize&gt;&amp;<sp/>group)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>On<sp/>find<sp/>or<sp/>inserted(no<sp/>work<sp/>thread<sp/>should<sp/>not<sp/>do<sp/>insertion),<sp/>return<sp/>local</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>slot<sp/>offset.<sp/>On<sp/>not<sp/>find<sp/>and<sp/>bucket<sp/>is<sp/>full,<sp/>return<sp/>-1.<sp/>Should<sp/>do<sp/>CAS</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>loop<sp/>cooperative_groups::thread_block_tile&lt;BucketSize&gt;<sp/>g<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>cooperative_groups::tiled_partition&lt;BucketSize&gt;(cooperative_groups::this_thread_block());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>KeyT*<sp/>key_ptr<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>table_keys_<sp/>+<sp/>bucket_id<sp/>*<sp/>BucketSize<sp/>+<sp/>group.thread_rank();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>KeyT<sp/>old_key<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>*key_ptr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>match_key<sp/>=<sp/>group.ballot(old_key<sp/>==<sp/>key);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>match_lane_id<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>__ffs(match_key)<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(match_lane_id<sp/>&gt;=<sp/>0)<sp/>{<sp/>return<sp/>match_lane_id;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>empty_key<sp/>=<sp/>group.ballot(old_key<sp/>==<sp/>AppendUniqueHash&lt;KeyT&gt;::kInvalidKey);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(empty_key<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>leader<sp/>=<sp/>__ffs((int)empty_key)<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>KeyT<sp/>old;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(group.thread_rank()<sp/>==<sp/>leader)<sp/>{<sp/>old<sp/>=<sp/>atomicCASSigned(key_ptr,<sp/>old_key,<sp/>key);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>old<sp/><sp/><sp/><sp/><sp/>=<sp/>group.shfl(old,<sp/>leader);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>old_key<sp/>=<sp/>group.shfl(old_key,<sp/>leader);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(old<sp/>==<sp/>old_key<sp/>||<sp/>old<sp/>==<sp/>key)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>success<sp/>and<sp/>duplicate.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>leader;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>empty_key<sp/>^=<sp/>(1UL<sp/>&lt;&lt;<sp/>(unsigned)leader);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>bucket_count_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>KeyT*<sp/>table_keys_<sp/><sp/>=<sp/>nullptr;<sp/><sp/>//<sp/>-1<sp/>invalid</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int32_t*<sp/>value_id_<sp/>=<sp/>nullptr;<sp/><sp/>//<sp/>-1<sp/>invalid,<sp/>-2<sp/>need<sp/>assign<sp/>final<sp/>neighbor<sp/>id</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>KeyT*<sp/>targets_<sp/><sp/><sp/>=<sp/>nullptr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>KeyT*<sp/>neighbors_<sp/>=<sp/>nullptr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>target_count_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>neighbor_count_;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>KeyT,<sp/>int<sp/>BucketSize,<sp/>bool<sp/>IsTarget&gt;</highlight></codeline>
<codeline><highlight class="normal">__global__<sp/>void<sp/>InsertKeysKernel(AppendUniqueHash&lt;KeyT,<sp/>BucketSize&gt;<sp/>auh)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>input_key_count<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>IsTarget<sp/>?<sp/>auh.TargetCount()<sp/>:<sp/>auh.NeighborCount();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>KeyT*<sp/>input_key_ptr<sp/>=<sp/>IsTarget<sp/>?<sp/>auh.Targets()<sp/>:<sp/>auh.Neighbors();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>key_idx<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>(blockIdx.x<sp/>*<sp/>blockDim.x<sp/>+<sp/>threadIdx.x)<sp/>/<sp/>BucketSize;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cooperative_groups::thread_block_tile&lt;BucketSize&gt;<sp/>group<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cooperative_groups::tiled_partition&lt;BucketSize&gt;(cooperative_groups::this_thread_block());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(key_idx<sp/>&gt;=<sp/>input_key_count)<sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>KeyT<sp/>key<sp/>=<sp/>input_key_ptr[key_idx];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>id<sp/><sp/><sp/>=<sp/>IsTarget<sp/>?<sp/>key_idx<sp/>:<sp/>AppendUniqueHash&lt;KeyT,<sp/>BucketSize&gt;::kNeedAssignValueID;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>auh.insert_key(key,<sp/>id,<sp/>group);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>KeyT,<sp/>int<sp/>BucketSize,<sp/>bool<sp/>IsTarget&gt;</highlight></codeline>
<codeline><highlight class="normal">__global__<sp/>void<sp/>RetrieveKeysKernel(AppendUniqueHash&lt;KeyT,<sp/>BucketSize&gt;<sp/>auh,<sp/>int*<sp/>output)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>input_key_count<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>IsTarget<sp/>?<sp/>auh.TargetCount()<sp/>:<sp/>auh.NeighborCount();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>KeyT*<sp/>input_key_ptr<sp/><sp/><sp/>=<sp/>IsTarget<sp/>?<sp/>auh.Targets()<sp/>:<sp/>auh.Neighbors();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int*<sp/>output_value_ptr<sp/>=<sp/>auh.ValueID();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>key_idx<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>(blockIdx.x<sp/>*<sp/>blockDim.x<sp/>+<sp/>threadIdx.x)<sp/>/<sp/>BucketSize;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cooperative_groups::thread_block_tile&lt;BucketSize&gt;<sp/>group<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cooperative_groups::tiled_partition&lt;BucketSize&gt;(cooperative_groups::this_thread_block());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(key_idx<sp/>&gt;=<sp/>input_key_count)<sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>KeyT<sp/>key<sp/><sp/><sp/>=<sp/>input_key_ptr[key_idx];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>offset<sp/>=<sp/>auh.retrieve_key(key,<sp/>group);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(group.thread_rank()<sp/>==<sp/>0)<sp/>{<sp/>output[key_idx]<sp/>=<sp/>output_value_ptr[offset];<sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>KeyT&gt;</highlight></codeline>
<codeline><highlight class="normal">__global__<sp/>void<sp/>CountBucketKernel(const<sp/>int*<sp/>value_id,<sp/>int*<sp/>bucket_count_ptr)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__shared__<sp/>int<sp/>count_buffer[kAssignThreadBlockSize<sp/>/<sp/>kAssignBucketSize];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>idx<sp/><sp/><sp/>=<sp/>blockIdx.x<sp/>*<sp/>blockDim.x<sp/>+<sp/>threadIdx.x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>value<sp/>=<sp/>value_id[idx];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>unsigned<sp/>int<sp/>assign_mask<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>__ballot_sync(0xffffffff,<sp/>value<sp/>==<sp/>AppendUniqueHash&lt;KeyT&gt;::kNeedAssignValueID);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(threadIdx.x<sp/>%<sp/>32<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>assign_count<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>__popc((int)assign_mask);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>count_buffer[threadIdx.x<sp/>/<sp/>32]<sp/>=<sp/>assign_count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__syncthreads();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(threadIdx.x<sp/>&lt;<sp/>kAssignThreadBlockSize<sp/>/<sp/>kAssignBucketSize)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bucket_count_ptr[kAssignThreadBlockSize<sp/>/<sp/>kAssignBucketSize<sp/>*<sp/>blockIdx.x<sp/>+<sp/>threadIdx.x]<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>count_buffer[threadIdx.x];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>KeyT&gt;</highlight></codeline>
<codeline><highlight class="normal">__global__<sp/>void<sp/>AssignValueKernel(int*<sp/>value_id,<sp/>const<sp/>int*<sp/>bucket_prefix_sum_ptr,<sp/>int<sp/>target_count)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>idx<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>blockIdx.x<sp/>*<sp/>blockDim.x<sp/>+<sp/>threadIdx.x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>warp_start<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>bucket_prefix_sum_ptr[idx<sp/>/<sp/>32];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>value<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>value_id[idx];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>unsigned<sp/>int<sp/>thread_mask<sp/>=<sp/>(1UL<sp/>&lt;&lt;<sp/>(threadIdx.x<sp/>%<sp/>32))<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>unsigned<sp/>int<sp/>assign_mask<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>__ballot_sync(0xffffffff,<sp/>value<sp/>==<sp/>AppendUniqueHash&lt;KeyT&gt;::kNeedAssignValueID);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>assign_mask<sp/>&amp;=<sp/>thread_mask;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>idx_in_warp<sp/><sp/>=<sp/>__popc((int)assign_mask);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>assigned_idx<sp/>=<sp/>idx_in_warp<sp/>+<sp/>warp_start;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(value<sp/>==<sp/>AppendUniqueHash&lt;KeyT&gt;::kNeedAssignValueID)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>value_id[idx]<sp/>=<sp/>assigned_idx<sp/>+<sp/>target_count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>KeyT&gt;</highlight></codeline>
<codeline><highlight class="normal">__global__<sp/>void<sp/>ComputeOutputUniqueNeighborAndCountKernel(const<sp/>KeyT*<sp/>table_keys,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>int*<sp/>value_ids,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>target_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>KeyT*<sp/>unique_total_output)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>idx<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>blockIdx.x<sp/>*<sp/>blockDim.x<sp/>+<sp/>threadIdx.x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>KeyT<sp/>key<sp/><sp/><sp/><sp/><sp/>=<sp/>table_keys[idx];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>value_id<sp/>=<sp/>value_ids[idx];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(value_id<sp/>&gt;=<sp/>target_count)<sp/>{<sp/>unique_total_output[value_id]<sp/>=<sp/>key;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>KeyT&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>graph_append_unique_func(void*<sp/>target_nodes_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_array_description_t<sp/>target_nodes_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void*<sp/>neighbor_nodes_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_array_description_t<sp/>neighbor_nodes_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void*<sp/>output_unique_node_memory_context,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int*<sp/>output_neighbor_raw_to_unique_mapping_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_env_func_t*<sp/>p_env_fns,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStream_t<sp/>stream)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>target_count<sp/><sp/><sp/>=<sp/>target_nodes_desc.size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>neighbor_count<sp/>=<sp/>neighbor_nodes_desc.size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AppendUniqueHash&lt;KeyT&gt;<sp/>auh(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>target_count,<sp/>neighbor_count,<sp/>(const<sp/>KeyT*)target_nodes_ptr,<sp/>(const<sp/>KeyT*)neighbor_nodes_ptr);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_ops::temp_memory_handle<sp/>hash_teable_keys_tmh(p_env_fns);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_ops::temp_memory_handle<sp/>hash_teable_values_tmh(p_env_fns);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>auh.AllocateMemoryAndInit(hash_teable_keys_tmh,<sp/>hash_teable_values_tmh,<sp/>stream);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>auh.InsertKeys(stream);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_ops::temp_memory_handle<sp/>bucket_count_tm(p_env_fns),<sp/>bucket_prefix_sum_tm(p_env_fns);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>num_bucket_count<sp/><sp/>=<sp/>raft::div_rounding_up_safe&lt;int&gt;(auh.SlotCount(),<sp/>kAssignBucketSize)<sp/>+<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int*<sp/>bucket_count_ptr<sp/>=<sp/>(int*)bucket_count_tm.device_malloc(num_bucket_count,<sp/>WHOLEMEMORY_DT_INT);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int*<sp/>bucket_prefix_sum_ptr<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(int*)bucket_prefix_sum_tm.device_malloc(num_bucket_count,<sp/>WHOLEMEMORY_DT_INT);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>KeyT*<sp/>table_keys<sp/>=<sp/>auh.TableKeys();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int*<sp/>value_id<sp/><sp/><sp/><sp/>=<sp/>auh.ValueID();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>num_blocks<sp/><sp/><sp/>=<sp/>raft::div_rounding_up_safe&lt;int&gt;(auh.SlotCount(),<sp/>kAssignThreadBlockSize);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CountBucketKernel&lt;KeyT&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;&lt;&lt;num_blocks,<sp/>kAssignThreadBlockSize,<sp/>0,<sp/>stream&gt;&gt;&gt;(value_id,<sp/>bucket_count_ptr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>WM_CUDA_CHECK(cudaGetLastError());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_ops::wm_thrust_allocator<sp/>thrust_allocator(p_env_fns);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>thrust::exclusive_scan(thrust::cuda::par_nosync(thrust_allocator).on(stream),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bucket_count_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bucket_count_ptr<sp/>+<sp/>num_bucket_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(int*)bucket_prefix_sum_ptr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>unique_neighbor_count<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>WM_CUDA_CHECK(cudaMemcpyAsync(&amp;unique_neighbor_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bucket_prefix_sum_ptr<sp/>+<sp/>num_bucket_count<sp/>-<sp/>1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sizeof(int),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMemcpyDeviceToHost,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stream));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>WM_CUDA_CHECK(cudaStreamSynchronize(stream));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>AssignValueKernel&lt;KeyT&gt;&lt;&lt;&lt;num_blocks,<sp/>kAssignThreadBlockSize,<sp/>0,<sp/>stream&gt;&gt;&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>value_id,<sp/>bucket_prefix_sum_ptr,<sp/>target_count);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_ops::output_memory_handle<sp/>gen_output_unique_node_buffer_mh(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>p_env_fns,<sp/>output_unique_node_memory_context);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>KeyT*<sp/>output_unique_node_ptr<sp/>=<sp/>(KeyT*)gen_output_unique_node_buffer_mh.device_malloc(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unique_neighbor_count<sp/>+<sp/>target_count,<sp/>target_nodes_desc.dtype);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>WM_CUDA_CHECK(cudaMemcpyAsync(output_unique_node_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>target_nodes_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>target_count<sp/>*<sp/>sizeof(KeyT),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMemcpyDeviceToDevice,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stream));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>ComputeOutputUniqueNeighborAndCountKernel&lt;KeyT&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;&lt;&lt;num_blocks,<sp/>kAssignThreadBlockSize,<sp/>0,<sp/>stream&gt;&gt;&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>table_keys,<sp/>value_id,<sp/>target_count,<sp/>output_unique_node_ptr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(output_neighbor_raw_to_unique_mapping_ptr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>auh.RetrieveNeighborKeysForValueIDs(stream,<sp/>(int*)output_neighbor_raw_to_unique_mapping_ptr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>WM_CUDA_CHECK(cudaStreamSynchronize(stream));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">}<sp/><sp/>//<sp/>namespace<sp/>graph_ops</highlight></codeline>
    </programlisting>
    <location file="src/graph_ops/append_unique_func.cuh"/>
  </compounddef>
</doxygen>
