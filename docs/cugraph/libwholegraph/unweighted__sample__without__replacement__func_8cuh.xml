<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="unweighted__sample__without__replacement__func_8cuh" kind="file" language="C++">
    <compoundname>unweighted_sample_without_replacement_func.cuh</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">/*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Copyright<sp/>(c)<sp/>2019-2024,<sp/>NVIDIA<sp/>CORPORATION.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Licensed<sp/>under<sp/>the<sp/>Apache<sp/>License,<sp/>Version<sp/>2.0<sp/>(the<sp/>&quot;License&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>you<sp/>may<sp/>not<sp/>use<sp/>this<sp/>file<sp/>except<sp/>in<sp/>compliance<sp/>with<sp/>the<sp/>License.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>You<sp/>may<sp/>obtain<sp/>a<sp/>copy<sp/>of<sp/>the<sp/>License<sp/>at</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/>http://www.apache.org/licenses/LICENSE-2.0</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Unless<sp/>required<sp/>by<sp/>applicable<sp/>law<sp/>or<sp/>agreed<sp/>to<sp/>in<sp/>writing,<sp/>software</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>distributed<sp/>under<sp/>the<sp/>License<sp/>is<sp/>distributed<sp/>on<sp/>an<sp/>&quot;AS<sp/>IS&quot;<sp/>BASIS,</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>WITHOUT<sp/>WARRANTIES<sp/>OR<sp/>CONDITIONS<sp/>OF<sp/>ANY<sp/>KIND,<sp/>either<sp/>express<sp/>or<sp/>implied.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>See<sp/>the<sp/>License<sp/>for<sp/>the<sp/>specific<sp/>language<sp/>governing<sp/>permissions<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>limitations<sp/>under<sp/>the<sp/>License.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>once</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;cub/device/device_radix_sort.cuh&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;random&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;thrust/scan.h&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;raft/random/rng_device.cuh&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;raft/random/rng_state.hpp&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;raft/util/integer_utils.hpp&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;wholememory/device_reference.cuh&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;wholememory/env_func_ptrs.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;wholememory/global_reference.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;wholememory/tensor_description.h&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;wholememory_ops/output_memory_handle.hpp&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;wholememory_ops/temp_memory_handle.hpp&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;wholememory_ops/thrust_allocator.hpp&quot;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;cuda_macros.hpp&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;error.hpp&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;sample_comm.cuh&quot;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">namespace<sp/>wholegraph_ops<sp/>{</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>IdType,<sp/>typename<sp/>WMOffsetType&gt;</highlight></codeline>
<codeline><highlight class="normal">__global__<sp/>void<sp/>get_sample_count_without_replacement_kernel(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_gref_t<sp/>wm_csr_row_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_array_description_t<sp/>wm_csr_row_ptr_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IdType*<sp/>input_nodes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>input_node_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int*<sp/>tmp_sample_count_mem_pointer,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>max_sample_count)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>gidx<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>input_idx<sp/>=<sp/>gidx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(input_idx<sp/>&gt;=<sp/>input_node_count)<sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IdType<sp/>nid<sp/>=<sp/>input_nodes[input_idx];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory::device_reference&lt;WMOffsetType&gt;<sp/>wm_csr_row_ptr_dev_ref(wm_csr_row_ptr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>start<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>wm_csr_row_ptr_dev_ref[nid];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>end<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>wm_csr_row_ptr_dev_ref[nid<sp/>+<sp/>1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>neighbor_count<sp/>=<sp/>(int)(end<sp/>-<sp/>start);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>sample_count<sp/>&lt;=<sp/>0<sp/>means<sp/>sample<sp/>all.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(max_sample_count<sp/>&gt;<sp/>0)<sp/>{<sp/>neighbor_count<sp/>=<sp/>min(neighbor_count,<sp/>max_sample_count);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tmp_sample_count_mem_pointer[input_idx]<sp/>=<sp/>neighbor_count;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>IdType,<sp/>typename<sp/>LocalIdType,<sp/>typename<sp/>WMIdType,<sp/>typename<sp/>WMOffsetType&gt;</highlight></codeline>
<codeline><highlight class="normal">__global__<sp/>void<sp/>large_sample_kernel(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_gref_t<sp/>wm_csr_row_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_array_description_t<sp/>wm_csr_row_ptr_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_gref_t<sp/>wm_csr_col_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_array_description_t<sp/>wm_csr_col_ptr_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IdType*<sp/>input_nodes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>input_node_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>max_sample_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>raft::random::detail::DeviceState&lt;raft::random::detail::PCGenerator&gt;<sp/>rngstate,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int*<sp/>sample_offset,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_array_description_t<sp/>sample_offset_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>WMIdType*<sp/>output,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int*<sp/>src_lid,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t*<sp/>output_edge_gid_ptr)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>input_idx<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(input_idx<sp/>&gt;=<sp/>input_node_count)<sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>gidx<sp/>=<sp/>threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>raft::random::detail::PCGenerator<sp/>rng(rngstate,<sp/>(uint64_t)gidx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory::device_reference&lt;WMOffsetType&gt;<sp/>csr_row_ptr_gen(wm_csr_row_ptr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory::device_reference&lt;WMIdType&gt;<sp/>csr_col_ptr_gen(wm_csr_col_ptr);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>IdType<sp/>nid<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>input_nodes[input_idx];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>start<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>csr_row_ptr_gen[nid];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>end<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>csr_row_ptr_gen[nid<sp/>+<sp/>1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>neighbor_count<sp/>=<sp/>(int)(end<sp/>-<sp/>start);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>offset<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>sample_offset[input_idx];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>sample<sp/>all</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(neighbor_count<sp/>&lt;=<sp/>max_sample_count)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>sample_id<sp/>=<sp/>threadIdx.x;<sp/>sample_id<sp/>&lt;<sp/>neighbor_count;<sp/>sample_id<sp/>+=<sp/>blockDim.x)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>neighbor_idx<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>sample_id;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>IdType<sp/>gid<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>csr_col_ptr_gen[start<sp/>+<sp/>neighbor_idx];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>output[offset<sp/>+<sp/>sample_id]<sp/>=<sp/>gid;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(src_lid)<sp/>src_lid[offset<sp/>+<sp/>sample_id]<sp/>=<sp/>(LocalIdType)input_idx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(output_edge_gid_ptr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>output_edge_gid_ptr[offset<sp/>+<sp/>sample_id]<sp/>=<sp/>(int64_t)(start<sp/>+<sp/>neighbor_idx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>sample_id<sp/>=<sp/>threadIdx.x;<sp/>sample_id<sp/>&lt;<sp/>max_sample_count;<sp/>sample_id<sp/>+=<sp/>blockDim.x)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>output[offset<sp/>+<sp/>sample_id]<sp/>=<sp/>(IdType)sample_id;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(src_lid)<sp/>src_lid[offset<sp/>+<sp/>sample_id]<sp/>=<sp/>(LocalIdType)input_idx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__syncthreads();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>idx<sp/>=<sp/>max_sample_count<sp/>+<sp/>threadIdx.x;<sp/>idx<sp/>&lt;<sp/>neighbor_count;<sp/>idx<sp/>+=<sp/>blockDim.x)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>raft::random::detail::UniformDistParams&lt;int32_t&gt;<sp/>params;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>params.start<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>params.end<sp/><sp/><sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int32_t<sp/>rand_num;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>raft::random::detail::custom_next(rng,<sp/>&amp;rand_num,<sp/>params,<sp/>0,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rand_num<sp/>%=<sp/>idx<sp/>+<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(rand_num<sp/>&lt;<sp/>max_sample_count)<sp/>{<sp/>atomicMax((int*)(output<sp/>+<sp/>offset<sp/>+<sp/>rand_num),<sp/>idx);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__syncthreads();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>sample_id<sp/>=<sp/>threadIdx.x;<sp/>sample_id<sp/>&lt;<sp/>max_sample_count;<sp/>sample_id<sp/>+=<sp/>blockDim.x)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>neighbor_idx<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>*(int*)(output<sp/>+<sp/>offset<sp/>+<sp/>sample_id);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>output[offset<sp/>+<sp/>sample_id]<sp/>=<sp/>csr_col_ptr_gen[start<sp/>+<sp/>neighbor_idx];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(output_edge_gid_ptr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>output_edge_gid_ptr[offset<sp/>+<sp/>sample_id]<sp/>=<sp/>(int64_t)(start<sp/>+<sp/>neighbor_idx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>IdType,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>LocalIdType,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>WMIdType,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>WMOffsetType,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>BLOCK_DIM<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>32,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>ITEMS_PER_THREAD<sp/>=<sp/>1&gt;</highlight></codeline>
<codeline><highlight class="normal">__global__<sp/>void<sp/>unweighted_sample_without_replacement_kernel(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_gref_t<sp/>wm_csr_row_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_array_description_t<sp/>wm_csr_row_ptr_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_gref_t<sp/>wm_csr_col_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_array_description_t<sp/>wm_csr_col_ptr_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>IdType*<sp/>input_nodes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>input_node_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>max_sample_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>raft::random::detail::DeviceState&lt;raft::random::detail::PCGenerator&gt;<sp/>rngstate,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int*<sp/>sample_offset,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_array_description_t<sp/>sample_offset_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>WMIdType*<sp/>output,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int*<sp/>src_lid,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t*<sp/>output_edge_gid_ptr)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>gidx<sp/>=<sp/>threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>raft::random::detail::PCGenerator<sp/>rng(rngstate,<sp/>(uint64_t)gidx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>input_idx<sp/>=<sp/>blockIdx.x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(input_idx<sp/>&gt;=<sp/>input_node_count)<sp/>return;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory::device_reference&lt;WMOffsetType&gt;<sp/>csr_row_ptr_gen(wm_csr_row_ptr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory::device_reference&lt;WMIdType&gt;<sp/>csr_col_ptr_gen(wm_csr_col_ptr);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>IdType<sp/>nid<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>input_nodes[input_idx];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>start<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>csr_row_ptr_gen[nid];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>end<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>csr_row_ptr_gen[nid<sp/>+<sp/>1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>neighbor_count<sp/>=<sp/>(int)(end<sp/>-<sp/>start);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(neighbor_count<sp/>&lt;=<sp/>0)<sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>offset<sp/>=<sp/>sample_offset[input_idx];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>use<sp/>all<sp/>neighbors<sp/>if<sp/>neighbors<sp/>less<sp/>than<sp/>max_sample_count</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(neighbor_count<sp/>&lt;=<sp/>max_sample_count)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>sample_id<sp/>=<sp/>threadIdx.x;<sp/>sample_id<sp/>&lt;<sp/>neighbor_count;<sp/>sample_id<sp/>+=<sp/>blockDim.x)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>IdType<sp/>gid<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>csr_col_ptr_gen[start<sp/>+<sp/>sample_id];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>output[offset<sp/>+<sp/>sample_id]<sp/>=<sp/>gid;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(src_lid)<sp/>src_lid[offset<sp/>+<sp/>sample_id]<sp/>=<sp/>input_idx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(output_edge_gid_ptr)<sp/>{<sp/>output_edge_gid_ptr[offset<sp/>+<sp/>sample_id]<sp/>=<sp/>start<sp/>+<sp/>sample_id;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>uint64_t<sp/>sa_p[ITEMS_PER_THREAD];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>M<sp/>=<sp/>max_sample_count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>N<sp/>=<sp/>neighbor_count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>UnWeightedIndexSampleWithOutReplacement&lt;BLOCK_DIM,<sp/>ITEMS_PER_THREAD&gt;(M,<sp/>N,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>sa_p,<sp/>rng);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>typedef<sp/>cub::BlockRadixSort&lt;uint64_t,<sp/>BLOCK_DIM,<sp/>ITEMS_PER_THREAD&gt;<sp/>BlockRadixSort;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>struct<sp/>IntArray<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>value[BLOCK_DIM<sp/>*<sp/>ITEMS_PER_THREAD];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>struct<sp/>SampleSharedData<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>IntArray<sp/>s;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>IntArray<sp/>p;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>IntArray<sp/>q;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>IntArray<sp/>chain;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>IntArray<sp/>last_chain_tmp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__shared__<sp/>union<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>typename<sp/>BlockRadixSort::TempStorage<sp/>temp_storage;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>SampleSharedData<sp/>sample_shared_data;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>shared_data;</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>unroll</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ITEMS_PER_THREAD;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>idx<sp/>=<sp/>i<sp/>*<sp/>BLOCK_DIM<sp/>+<sp/>threadIdx.x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>raft::random::detail::UniformDistParams&lt;int32_t&gt;<sp/>params;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>params.start<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>params.end<sp/><sp/><sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int32_t<sp/>rand_num;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>raft::random::detail::custom_next(rng,<sp/>&amp;rand_num,<sp/>params,<sp/>0,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int32_t<sp/>r<sp/>=<sp/>idx<sp/>&lt;<sp/>M<sp/>?<sp/>rand_num<sp/>%<sp/>(N<sp/>-<sp/>idx)<sp/>:<sp/>N;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sa_p[i]<sp/><sp/><sp/>=<sp/>((uint64_t)r<sp/>&lt;&lt;<sp/>32UL)<sp/>|<sp/>idx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__syncthreads();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>BlockRadixSort(shared_data.temp_storage).SortBlockedToStriped(sa_p);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__syncthreads();</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>unroll</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ITEMS_PER_THREAD;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>idx<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>i<sp/>*<sp/>BLOCK_DIM<sp/>+<sp/>threadIdx.x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>s<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>(int)(sa_p[i]<sp/>&gt;&gt;<sp/>32UL);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>shared_data.sample_shared_data.s.value[idx]<sp/>=<sp/>s;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>p<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>sa_p[i]<sp/>&amp;<sp/>0xFFFFFFFF;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>shared_data.sample_shared_data.p.value[idx]<sp/>=<sp/>p;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(idx<sp/>&lt;<sp/>M)<sp/>shared_data.sample_shared_data.q.value[p]<sp/>=<sp/>idx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>shared_data.sample_shared_data.chain.value[idx]<sp/>=<sp/>idx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__syncthreads();</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>unroll</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ITEMS_PER_THREAD;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>idx<sp/>=<sp/>i<sp/>*<sp/>BLOCK_DIM<sp/>+<sp/>threadIdx.x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>si<sp/><sp/>=<sp/>shared_data.sample_shared_data.s.value[idx];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>si1<sp/>=<sp/>shared_data.sample_shared_data.s.value[idx<sp/>+<sp/>1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(idx<sp/>&lt;<sp/>M<sp/>&amp;&amp;<sp/>(idx<sp/>==<sp/>M<sp/>-<sp/>1<sp/>||<sp/>si<sp/>!=<sp/>si1)<sp/>&amp;&amp;<sp/>si<sp/>&gt;=<sp/>N<sp/>-<sp/>M)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>shared_data.sample_shared_data.chain.value[N<sp/>-<sp/>si<sp/>-<sp/>1]<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shared_data.sample_shared_data.p.value[idx];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__syncthreads();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>step<sp/>=<sp/>0;<sp/>step<sp/>&lt;<sp/>log2_up_device(M);<sp/>++step)<sp/>{</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>unroll</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ITEMS_PER_THREAD;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>idx<sp/>=<sp/>i<sp/>*<sp/>BLOCK_DIM<sp/>+<sp/>threadIdx.x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>shared_data.sample_shared_data.last_chain_tmp.value[idx]<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shared_data.sample_shared_data.chain.value[idx];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>__syncthreads();</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>unroll</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ITEMS_PER_THREAD;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>idx<sp/>=<sp/>i<sp/>*<sp/>BLOCK_DIM<sp/>+<sp/>threadIdx.x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(idx<sp/>&lt;<sp/>M)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shared_data.sample_shared_data.chain.value[idx]<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shared_data.sample_shared_data.last_chain_tmp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.value[shared_data.sample_shared_data.last_chain_tmp.value[idx]];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>__syncthreads();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>unroll</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ITEMS_PER_THREAD;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>idx<sp/>=<sp/>i<sp/>*<sp/>BLOCK_DIM<sp/>+<sp/>threadIdx.x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>shared_data.sample_shared_data.last_chain_tmp.value[idx]<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>N<sp/>-<sp/>shared_data.sample_shared_data.chain.value[idx]<sp/>-<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__syncthreads();</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>unroll</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ITEMS_PER_THREAD;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>idx<sp/>=<sp/>i<sp/>*<sp/>BLOCK_DIM<sp/>+<sp/>threadIdx.x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>ai;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(idx<sp/>&lt;<sp/>M)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>qi<sp/>=<sp/>shared_data.sample_shared_data.q.value[idx];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(idx<sp/>==<sp/>0<sp/>||<sp/>qi<sp/>==<sp/>0<sp/>||</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shared_data.sample_shared_data.s.value[qi]<sp/>!=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shared_data.sample_shared_data.s.value[qi<sp/>-<sp/>1])<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ai<sp/>=<sp/>shared_data.sample_shared_data.s.value[qi];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>prev_i<sp/>=<sp/>shared_data.sample_shared_data.p.value[qi<sp/>-<sp/>1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ai<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>shared_data.sample_shared_data.last_chain_tmp.value[prev_i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>sa_p[i]<sp/>=<sp/>ai;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Output</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>unroll</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ITEMS_PER_THREAD;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>idx<sp/>=<sp/>i<sp/>*<sp/>BLOCK_DIM<sp/>+<sp/>threadIdx.x;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>ai<sp/><sp/>=<sp/>sa_p[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(idx<sp/>&lt;<sp/>M)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>IdType<sp/>gid<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>csr_col_ptr_gen[start<sp/>+<sp/>ai];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>output[offset<sp/>+<sp/>idx]<sp/>=<sp/>gid;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(src_lid)<sp/>src_lid[offset<sp/>+<sp/>idx]<sp/>=<sp/>(LocalIdType)input_idx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(output_edge_gid_ptr)<sp/>{<sp/>output_edge_gid_ptr[offset<sp/>+<sp/>idx]<sp/>=<sp/>(int64_t)(start<sp/>+<sp/>ai);<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>IdType,<sp/>typename<sp/>WMIdType&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>wholegraph_csr_unweighted_sample_without_replacement_func(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_gref_t<sp/>wm_csr_row_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_array_description_t<sp/>wm_csr_row_ptr_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_gref_t<sp/>wm_csr_col_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_array_description_t<sp/>wm_csr_col_ptr_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void*<sp/>center_nodes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_array_description_t<sp/>center_nodes_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>max_sample_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void*<sp/>output_sample_offset,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_array_description_t<sp/>output_sample_offset_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void*<sp/>output_dest_memory_context,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void*<sp/>output_center_localid_memory_context,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void*<sp/>output_edge_gid_memory_context,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>unsigned<sp/>long<sp/>long<sp/>random_seed,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_env_func_t*<sp/>p_env_fns,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cudaStream_t<sp/>stream)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>center_node_count<sp/>=<sp/>center_nodes_desc.size;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>WHOLEMEMORY_EXPECTS(wm_csr_row_ptr_desc.dtype<sp/>==<sp/>WHOLEMEMORY_DT_INT64,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;wholegraph_csr_unweighted_sample_without_replacement_func().<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;wm_csr_row_ptr_desc.dtype<sp/>!=<sp/>WHOLEMEMORY_DT_INT64,<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;wm_csr_row_ptr_desc.dtype<sp/>=<sp/>%d&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wm_csr_row_ptr_desc.dtype);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>WHOLEMEMORY_EXPECTS(output_sample_offset_desc.dtype<sp/>==<sp/>WHOLEMEMORY_DT_INT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;wholegraph_csr_unweighted_sample_without_replacement_func().<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;output_sample_offset_desc.dtype<sp/>!=<sp/>WHOLEMEMORY_DT_INT,<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;output_sample_offset_desc.dtype<sp/>=<sp/>%d&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>output_sample_offset_desc.dtype);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_ops::temp_memory_handle<sp/>gen_buffer_tmh(p_env_fns);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int*<sp/>tmp_sample_count_mem_pointer<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(int*)gen_buffer_tmh.device_malloc(center_node_count<sp/>+<sp/>1,<sp/>WHOLEMEMORY_DT_INT);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>thread_x<sp/><sp/><sp/><sp/>=<sp/>32;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>block_count<sp/>=<sp/>raft::div_rounding_up_safe&lt;int&gt;(center_node_count,<sp/>thread_x);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>get_sample_count_without_replacement_kernel&lt;IdType,<sp/>int64_t&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&lt;&lt;&lt;block_count,<sp/>thread_x,<sp/>0,<sp/>stream&gt;&gt;&gt;(wm_csr_row_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wm_csr_row_ptr_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(const<sp/>IdType*)center_nodes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>center_node_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tmp_sample_count_mem_pointer,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>max_sample_count);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>WM_CUDA_CHECK(cudaGetLastError());</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>prefix<sp/>sum</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_ops::wm_thrust_allocator<sp/>thrust_allocator(p_env_fns);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>thrust::exclusive_scan(thrust::cuda::par_nosync(thrust_allocator).on(stream),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tmp_sample_count_mem_pointer,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tmp_sample_count_mem_pointer<sp/>+<sp/>center_node_count<sp/>+<sp/>1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(int*)output_sample_offset);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>WM_CUDA_CHECK(cudaMemcpyAsync(&amp;count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>((int*)output_sample_offset)<sp/>+<sp/>center_node_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sizeof(int),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMemcpyDeviceToHost,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stream));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>WM_CUDA_CHECK(cudaStreamSynchronize(stream));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_ops::output_memory_handle<sp/>gen_output_dest_buffer_mh(p_env_fns,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>output_dest_memory_context);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>WMIdType*<sp/>output_dest_node_ptr<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(WMIdType*)gen_output_dest_buffer_mh.device_malloc(count,<sp/>wm_csr_col_ptr_desc.dtype);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int*<sp/>output_center_localid_ptr<sp/>=<sp/>nullptr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(output_center_localid_memory_context)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>wholememory_ops::output_memory_handle<sp/>gen_output_center_localid_buffer_mh(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>p_env_fns,<sp/>output_center_localid_memory_context);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>output_center_localid_ptr<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>(int*)gen_output_center_localid_buffer_mh.device_malloc(count,<sp/>WHOLEMEMORY_DT_INT);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t*<sp/>output_edge_gid_ptr<sp/>=<sp/>nullptr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(output_edge_gid_memory_context)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>wholememory_ops::output_memory_handle<sp/>gen_output_edge_gid_buffer_mh(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>p_env_fns,<sp/>output_edge_gid_memory_context);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>output_edge_gid_ptr<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>(int64_t*)gen_output_edge_gid_buffer_mh.device_malloc(count,<sp/>WHOLEMEMORY_DT_INT64);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>sample<sp/>node</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>raft::random::RngState<sp/>_rngstate(random_seed,<sp/>0,<sp/>raft::random::GeneratorType::GenPC);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>raft::random::detail::DeviceState&lt;raft::random::detail::PCGenerator&gt;<sp/>rngstate(_rngstate);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(max_sample_count<sp/>&lt;=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>sample_all_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;&lt;center_node_count,<sp/>64,<sp/>0,<sp/>stream&gt;&gt;&gt;(wm_csr_row_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wm_csr_row_ptr_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wm_csr_col_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wm_csr_col_ptr_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(const<sp/>IdType*)center_nodes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>center_node_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(const<sp/>int*)output_sample_offset,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>output_sample_offset_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(WMIdType*)output_dest_node_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(int*)output_center_localid_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(int64_t*)output_edge_gid_ptr);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>WM_CUDA_CHECK(cudaGetLastError());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>WM_CUDA_CHECK(cudaStreamSynchronize(stream));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(max_sample_count<sp/>&gt;<sp/>1024)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>large_sample_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;&lt;center_node_count,<sp/>32,<sp/>0,<sp/>stream&gt;&gt;&gt;(wm_csr_row_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wm_csr_row_ptr_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wm_csr_col_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wm_csr_col_ptr_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(const<sp/>IdType*)center_nodes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>center_node_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>max_sample_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rngstate,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(const<sp/>int*)output_sample_offset,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>output_sample_offset_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(WMIdType*)output_dest_node_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(int*)output_center_localid_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(int64_t*)output_edge_gid_ptr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>WM_CUDA_CHECK(cudaGetLastError());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>WM_CUDA_CHECK(cudaStreamSynchronize(stream));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>typedef<sp/>void<sp/>(*unweighted_sample_func_type)(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>wholememory_gref_t<sp/>wm_csr_row_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>wholememory_array_description_t<sp/>wm_csr_row_ptr_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>wholememory_gref_t<sp/>wm_csr_col_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>wholememory_array_description_t<sp/>wm_csr_col_ptr_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>IdType*<sp/>input_nodes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>int<sp/>input_node_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>int<sp/>max_sample_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>raft::random::detail::DeviceState&lt;raft::random::detail::PCGenerator&gt;<sp/>rngstate,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>int*<sp/>sample_offset,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>wholememory_array_description_t<sp/>sample_offset_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>WMIdType*<sp/>output,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int*<sp/>src_lid,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int64_t*<sp/>output_edge_gid_ptr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>const<sp/>unweighted_sample_func_type<sp/>func_array[32]<sp/>=<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>32,<sp/>1&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>32,<sp/>2&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>32,<sp/>3&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>64,<sp/>2&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>64,<sp/>3&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>64,<sp/>3&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>128,<sp/>2&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>128,<sp/>2&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>128,<sp/>3&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>128,<sp/>3&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>128,<sp/>3&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>128,<sp/>3&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>256,<sp/>2&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>256,<sp/>2&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>256,<sp/>2&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>256,<sp/>2&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>256,<sp/>3&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>256,<sp/>3&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>256,<sp/>3&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>256,<sp/>3&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>256,<sp/>3&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>256,<sp/>3&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>256,<sp/>3&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>256,<sp/>3&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>256,<sp/>4&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>256,<sp/>4&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>256,<sp/>4&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>256,<sp/>4&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>256,<sp/>4&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>256,<sp/>4&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>256,<sp/>4&gt;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unweighted_sample_without_replacement_kernel&lt;IdType,<sp/>int,<sp/>WMIdType,<sp/>int64_t,<sp/>256,<sp/>4&gt;};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>const<sp/>int<sp/>warp_count_array[32]<sp/>=<sp/>{1,<sp/>1,<sp/>1,<sp/>2,<sp/>2,<sp/>2,<sp/>4,<sp/>4,<sp/>4,<sp/>4,<sp/>4,<sp/>4,<sp/>8,<sp/>8,<sp/>8,<sp/>8,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>8,<sp/>8,<sp/>8,<sp/>8,<sp/>8,<sp/>8,<sp/>8,<sp/>8,<sp/>8,<sp/>8,<sp/>8,<sp/>8,<sp/>8,<sp/>8,<sp/>8,<sp/>8};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>func_idx<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>(max_sample_count<sp/>-<sp/>1)<sp/>/<sp/>32;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>func_array[func_idx]&lt;&lt;&lt;center_node_count,<sp/>warp_count_array[func_idx]<sp/>*<sp/>32,<sp/>0,<sp/>stream&gt;&gt;&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>wm_csr_row_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>wm_csr_row_ptr_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>wm_csr_col_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>wm_csr_col_ptr_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(const<sp/>IdType*)center_nodes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>center_node_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>max_sample_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rngstate,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(const<sp/>int*)output_sample_offset,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>output_sample_offset_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(WMIdType*)output_dest_node_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(int*)output_center_localid_ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>(int64_t*)output_edge_gid_ptr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>WM_CUDA_CHECK(cudaGetLastError());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>WM_CUDA_CHECK(cudaStreamSynchronize(stream));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">}<sp/><sp/>//<sp/>namespace<sp/>wholegraph_ops</highlight></codeline>
    </programlisting>
    <location file="src/wholegraph_ops/unweighted_sample_without_replacement_func.cuh"/>
  </compounddef>
</doxygen>
