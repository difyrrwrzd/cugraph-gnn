<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="gather__scatter__func_8cuh" kind="file" language="C++">
    <compoundname>gather_scatter_func.cuh</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">/*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Copyright<sp/>(c)<sp/>2019-2024,<sp/>NVIDIA<sp/>CORPORATION.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Licensed<sp/>under<sp/>the<sp/>Apache<sp/>License,<sp/>Version<sp/>2.0<sp/>(the<sp/>&quot;License&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>you<sp/>may<sp/>not<sp/>use<sp/>this<sp/>file<sp/>except<sp/>in<sp/>compliance<sp/>with<sp/>the<sp/>License.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>You<sp/>may<sp/>obtain<sp/>a<sp/>copy<sp/>of<sp/>the<sp/>License<sp/>at</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/><sp/><sp/><sp/><sp/>http://www.apache.org/licenses/LICENSE-2.0</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Unless<sp/>required<sp/>by<sp/>applicable<sp/>law<sp/>or<sp/>agreed<sp/>to<sp/>in<sp/>writing,<sp/>software</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>distributed<sp/>under<sp/>the<sp/>License<sp/>is<sp/>distributed<sp/>on<sp/>an<sp/>&quot;AS<sp/>IS&quot;<sp/>BASIS,</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>WITHOUT<sp/>WARRANTIES<sp/>OR<sp/>CONDITIONS<sp/>OF<sp/>ANY<sp/>KIND,<sp/>either<sp/>express<sp/>or<sp/>implied.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>See<sp/>the<sp/>License<sp/>for<sp/>the<sp/>specific<sp/>language<sp/>governing<sp/>permissions<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>limitations<sp/>under<sp/>the<sp/>License.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>once</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;cuda_bf16.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;cuda_fp16.h&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;wholememory/device_reference.cuh&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;wholememory/global_reference.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;wholememory/tensor_description.h&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;cuda_macros.hpp&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;error.hpp&quot;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;wholememory/integer_utils.hpp&quot;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;cooperative_groups.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;cooperative_groups/memcpy_async.h&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">namespace<sp/>wholememory_ops<sp/>{</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>DataTypeT&gt;</highlight></codeline>
<codeline><highlight class="normal">__device__<sp/>__forceinline__<sp/>void<sp/>mov_typed_data(DataTypeT*<sp/>to,<sp/>const<sp/>DataTypeT*<sp/>from)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*to<sp/>=<sp/>*from;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;int<sp/>DATA_SIZE&gt;</highlight></codeline>
<codeline><highlight class="normal">__device__<sp/>__forceinline__<sp/>void<sp/>mov_data(void*<sp/>to,<sp/>const<sp/>void*<sp/>from)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>char*<sp/>ptr_to<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>static_cast&lt;char*&gt;(to);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>char*<sp/>ptr_from<sp/>=<sp/>static_cast&lt;const<sp/>char*&gt;(from);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>DATA_SIZE;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ptr_to[i]<sp/>=<sp/>ptr_from[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>DataTypeT,<sp/>int<sp/>DATA_SIZE&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>typed_data_vector<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>DataTypeT<sp/>data[DATA_SIZE];</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>typed_data_vector&lt;double,<sp/>2&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>double2<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>typed_data_vector&lt;int64_t,<sp/>2&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int4<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>typed_data_vector&lt;float,<sp/>2&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>float2<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>typed_data_vector&lt;float,<sp/>4&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>float4<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>typed_data_vector&lt;int,<sp/>2&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int2<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>typed_data_vector&lt;int,<sp/>4&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int4<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>typed_data_vector&lt;__half,<sp/>2&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__half2<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>typed_data_vector&lt;__half,<sp/>4&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int2<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>typed_data_vector&lt;__half,<sp/>8&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int4<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>typed_data_vector&lt;int16_t,<sp/>2&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>typed_data_vector&lt;int16_t,<sp/>4&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int2<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>typed_data_vector&lt;int16_t,<sp/>8&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int4<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>typed_data_vector&lt;nv_bfloat16,<sp/>2&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>nv_bfloat162<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>typed_data_vector&lt;nv_bfloat16,<sp/>4&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int2<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>typed_data_vector&lt;nv_bfloat16,<sp/>8&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int4<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>typed_data_vector&lt;int8_t,<sp/>2&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int16_t<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>typed_data_vector&lt;int8_t,<sp/>4&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>typed_data_vector&lt;int8_t,<sp/>8&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int2<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>typed_data_vector&lt;int8_t,<sp/>16&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int4<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>DataTypeT,<sp/>int<sp/>DATA_SIZE&gt;</highlight></codeline>
<codeline><highlight class="normal">__device__<sp/>__forceinline__<sp/>DataTypeT&amp;<sp/>typed_data_vector_at(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>typed_data_vector&lt;DataTypeT,<sp/>DATA_SIZE&gt;&amp;<sp/>v,<sp/>int<sp/>idx)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>((DataTypeT*)(&amp;v.data))[idx];</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">__device__<sp/>__forceinline__<sp/>void<sp/>mov_data&lt;1&gt;(void*<sp/>to,<sp/>const<sp/>void*<sp/>from)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mov_typed_data(static_cast&lt;int8_t*&gt;(to),<sp/>static_cast&lt;const<sp/>int8_t*&gt;(from));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">__device__<sp/>__forceinline__<sp/>void<sp/>mov_data&lt;2&gt;(void*<sp/>to,<sp/>const<sp/>void*<sp/>from)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mov_typed_data(static_cast&lt;int16_t*&gt;(to),<sp/>static_cast&lt;const<sp/>int16_t*&gt;(from));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">__device__<sp/>__forceinline__<sp/>void<sp/>mov_data&lt;4&gt;(void*<sp/>to,<sp/>const<sp/>void*<sp/>from)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mov_typed_data(static_cast&lt;int32_t*&gt;(to),<sp/>static_cast&lt;const<sp/>int32_t*&gt;(from));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">__device__<sp/>__forceinline__<sp/>void<sp/>mov_data&lt;8&gt;(void*<sp/>to,<sp/>const<sp/>void*<sp/>from)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mov_typed_data(static_cast&lt;int64_t*&gt;(to),<sp/>static_cast&lt;const<sp/>int64_t*&gt;(from));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">__device__<sp/>__forceinline__<sp/>void<sp/>mov_data&lt;16&gt;(void*<sp/>to,<sp/>const<sp/>void*<sp/>from)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mov_typed_data(static_cast&lt;int4*&gt;(to),<sp/>static_cast&lt;const<sp/>int4*&gt;(from));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>DataTypeT&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>type_caster<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>LoadTypeT<sp/><sp/>=<sp/>DataTypeT;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>StoreTypeT<sp/>=<sp/>DataTypeT;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>__device__<sp/>__forceinline__<sp/>LoadTypeT<sp/>convert_load_data(DataTypeT<sp/>data)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;LoadTypeT&gt;(data);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>__device__<sp/>__forceinline__<sp/>DataTypeT<sp/>convert_store_data(StoreTypeT<sp/>data)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;DataTypeT&gt;(data);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>type_caster&lt;__half&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>LoadTypeT<sp/><sp/>=<sp/>float;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>StoreTypeT<sp/>=<sp/>float;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>__device__<sp/>__forceinline__<sp/>LoadTypeT<sp/>convert_load_data(__half<sp/>data)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;LoadTypeT&gt;(data);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>__device__<sp/>__forceinline__<sp/>__half<sp/>convert_store_data(StoreTypeT<sp/>data)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;__half&gt;(data);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">template<sp/>&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>type_caster&lt;__nv_bfloat16&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>LoadTypeT<sp/><sp/>=<sp/>float;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>using<sp/>StoreTypeT<sp/>=<sp/>float;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>__device__<sp/>LoadTypeT<sp/>convert_load_data(__nv_bfloat16<sp/>data)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;LoadTypeT&gt;(data);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>__device__<sp/>__nv_bfloat16<sp/>convert_store_data(StoreTypeT<sp/>data)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;__nv_bfloat16&gt;(data);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>FromT,<sp/>typename<sp/>ToT&gt;</highlight></codeline>
<codeline><highlight class="normal">__device__<sp/>__forceinline__<sp/>ToT<sp/>convert_type(FromT<sp/>from)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>type_caster&lt;ToT&gt;::convert_store_data(type_caster&lt;FromT&gt;::convert_load_data(from));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Determine<sp/>alignment<sp/>of<sp/>a<sp/>WholeMemory<sp/>matrix,<sp/>in<sp/>element<sp/>count,<sp/>maximum<sp/>16<sp/>/<sp/>element_size.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>@param<sp/>embedding_desc<sp/>:<sp/>wholememory_matrix_description_t<sp/>matrix<sp/>description.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>@return<sp/>:<sp/>Alignment<sp/>that<sp/>can<sp/>be<sp/>used,<sp/>in<sp/>element<sp/>count.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">inline<sp/>int<sp/>determine_wholememory_alignment_elt_count(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory_matrix_description_t<sp/>embedding_desc)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>elt_size<sp/>=<sp/>static_cast&lt;int&gt;(wholememory_dtype_get_element_size(embedding_desc.dtype));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>WHOLEMEMORY_CHECK(elt_size<sp/>!=<sp/>-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>alignment<sp/>=<sp/>16<sp/>/<sp/>elt_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(;<sp/>alignment<sp/>&gt;<sp/>1;<sp/>alignment<sp/>/=<sp/>2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(embedding_desc.storage_offset<sp/>%<sp/>alignment<sp/>==<sp/>0<sp/>&amp;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>embedding_desc.sizes[1]<sp/>%<sp/>alignment<sp/>==<sp/>0<sp/>&amp;&amp;<sp/>embedding_desc.stride<sp/>%<sp/>alignment<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>alignment;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">/**</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Determine<sp/>alignment<sp/>of<sp/>normal<sp/>memory,<sp/>in<sp/>element<sp/>count,<sp/>maximum<sp/>16<sp/>/<sp/>element_size.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>@param<sp/>ptr<sp/>:<sp/>pointer<sp/>to<sp/>the<sp/>memory.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>@param<sp/>memory_desc<sp/>:<sp/>wholememory_matrix_description_t<sp/>matrix<sp/>description.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>@return<sp/>:<sp/>Alignment<sp/>that<sp/>can<sp/>be<sp/>used,<sp/>in<sp/>element<sp/>count.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline><highlight class="normal">inline<sp/>int<sp/>determine_memory_alignment_elt_count(const<sp/>void*<sp/>ptr,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t<sp/>memory_desc)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>elt_size<sp/>=<sp/>static_cast&lt;int&gt;(wholememory_dtype_get_element_size(memory_desc.dtype));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>WHOLEMEMORY_CHECK(elt_size<sp/>!=<sp/>-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>alignment<sp/><sp/><sp/>=<sp/>16<sp/>/<sp/>elt_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>int_ptr<sp/>=<sp/>reinterpret_cast&lt;int64_t&gt;(ptr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>WHOLEMEMORY_CHECK(int_ptr<sp/>%<sp/>elt_size<sp/>==<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int_ptr<sp/>/=<sp/>elt_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int_ptr<sp/>+=<sp/>memory_desc.storage_offset;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(;<sp/>alignment<sp/>&gt;<sp/>1;<sp/>alignment<sp/>/=<sp/>2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(int_ptr<sp/>%<sp/>alignment<sp/>==<sp/>0<sp/>&amp;&amp;<sp/>memory_desc.sizes[1]<sp/>%<sp/>alignment<sp/>==<sp/>0<sp/>&amp;&amp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memory_desc.stride<sp/>%<sp/>alignment<sp/>==<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>alignment;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>EmbeddingT,<sp/>typename<sp/>IndexT,<sp/>typename<sp/>OutputT,<sp/>int<sp/>ALIGNMENT<sp/>=<sp/>1&gt;</highlight></codeline>
<codeline><highlight class="normal">__global__<sp/>void<sp/>gather_func_kernel(wholememory_gref_t<sp/>embedding_gref,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t<sp/>embedding_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IndexT*<sp/>indices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int64_t<sp/>indice_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>gather_with_sorted_ids,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IndexT*<sp/>raw_indices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>OutputT*<sp/>output,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t<sp/>output_desc)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto<sp/>block<sp/><sp/>=<sp/>cooperative_groups::this_thread_block();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto<sp/>mywarp<sp/>=<sp/>cooperative_groups::tiled_partition&lt;32&gt;(block);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__shared__<sp/>char<sp/>shm_in_char[16384];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OutputT*<sp/>all_sh<sp/>=<sp/>reinterpret_cast&lt;OutputT*&gt;(shm_in_char);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OutputT*<sp/>my_shared;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>warp_id<sp/>=<sp/>(threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x)<sp/>/<sp/>32;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>lane_id<sp/>=<sp/>threadIdx.x<sp/>%<sp/>32;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>embedding_size<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>embedding_desc.sizes[1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>embedding_stride<sp/>=<sp/>embedding_desc.stride;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>output_stride<sp/><sp/><sp/><sp/>=<sp/>output_desc.stride;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>shm_size<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>16384<sp/>/<sp/>sizeof(OutputT);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory::device_reference&lt;EmbeddingT&gt;<sp/>embedding_dev_ref(embedding_gref);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>typed_data_vector&lt;EmbeddingT,<sp/>ALIGNMENT&gt;<sp/>embeddings;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>typed_data_vector&lt;OutputT,<sp/>ALIGNMENT&gt;<sp/>outputs;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>use_shm<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(shm_size<sp/>/<sp/>(blockDim.x<sp/>/<sp/>32)<sp/>&lt;<sp/>output_desc.sizes[1])<sp/>{<sp/><sp/>//</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>use_shm<sp/>=<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>my_shared<sp/>=<sp/>all_sh<sp/>+<sp/>shm_size<sp/>/<sp/>(blockDim.x<sp/>/<sp/>32)<sp/>*<sp/>(threadIdx.x<sp/>/<sp/>32);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int64_t<sp/>output_idx<sp/>=<sp/>warp_id;<sp/>output_idx<sp/>&lt;<sp/>indice_count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>output_idx<sp/>+=<sp/>gridDim.x<sp/>*<sp/>(blockDim.x<sp/>/<sp/>32))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int64_t<sp/>raw_output_idx<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>gather_with_sorted_ids<sp/>?<sp/>(int64_t)(raw_indices[output_idx])<sp/>:<sp/>output_idx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OutputT*<sp/>output_ptr<sp/>=<sp/>output<sp/>+<sp/>output_desc.storage_offset<sp/>+<sp/>output_stride<sp/>*<sp/>raw_output_idx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(!use_shm)<sp/>{<sp/>my_shared<sp/>=<sp/>output_ptr;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int64_t<sp/>embedding_table_idx<sp/>=<sp/>indices[output_idx];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(embedding_table_idx<sp/>&lt;<sp/>0)<sp/>continue;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>EmbeddingT*<sp/>emb_ptr<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&amp;embedding_dev_ref[embedding_desc.storage_offset<sp/>+<sp/>embedding_table_idx<sp/>*<sp/>embedding_stride];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>emb_idx<sp/>=<sp/>lane_id<sp/>*<sp/>ALIGNMENT;<sp/>emb_idx<sp/>&lt;<sp/>embedding_size;<sp/>emb_idx<sp/>+=<sp/>ALIGNMENT<sp/>*<sp/>32)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>mov_data&lt;sizeof(EmbeddingT)<sp/>*<sp/>ALIGNMENT&gt;(&amp;embeddings,<sp/>emb_ptr<sp/>+<sp/>emb_idx);</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>unroll</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>sub_idx<sp/>=<sp/>0;<sp/>sub_idx<sp/>&lt;<sp/>ALIGNMENT;<sp/>sub_idx++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typed_data_vector_at(outputs,<sp/>sub_idx)<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>convert_type&lt;EmbeddingT,<sp/>OutputT&gt;(typed_data_vector_at(embeddings,<sp/>sub_idx));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>mov_data&lt;sizeof(OutputT)<sp/>*<sp/>ALIGNMENT&gt;(my_shared<sp/>+<sp/>emb_idx,<sp/>&amp;outputs);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(use_shm)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>copy_size<sp/>=<sp/>output_desc.sizes[1]<sp/>*<sp/>sizeof(OutputT);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>cooperative_groups::memcpy_async(mywarp,<sp/>output_ptr,<sp/>my_shared,<sp/>copy_size);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>cooperative_groups::wait(mywarp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;int<sp/>N&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>IsPowerOfTwo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>constexpr<sp/>bool<sp/>value<sp/>=<sp/>(N<sp/>&gt;<sp/>0)<sp/>&amp;&amp;<sp/>((N<sp/>&amp;<sp/>(N<sp/>-<sp/>1))<sp/>==<sp/>0);</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>EmbeddingT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>IndexT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typename<sp/>OutputT,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>SUB_WARP_SIZE<sp/>=<sp/>1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>ALIGNMENT<sp/><sp/><sp/><sp/><sp/>=<sp/>1&gt;</highlight></codeline>
<codeline><highlight class="normal">__global__<sp/>void<sp/>gather_func_sub_warp_kernel(wholememory_gref_t<sp/>embedding_gref,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t<sp/>embedding_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IndexT*<sp/>indices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int64_t<sp/>indice_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>gather_with_sorted_ids,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IndexT*<sp/>raw_indices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>OutputT*<sp/>output,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t<sp/>output_desc)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static_assert(IsPowerOfTwo&lt;SUB_WARP_SIZE&gt;::value<sp/>&amp;&amp;<sp/>SUB_WARP_SIZE<sp/>&lt;<sp/>32,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;SUB_WARP_SIZE<sp/>must<sp/>be<sp/>the<sp/>power<sp/>of<sp/>2,and<sp/>smaller<sp/>than<sp/>32.&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto<sp/>block<sp/>=<sp/>cooperative_groups::this_thread_block();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto<sp/>subwarp<sp/><sp/><sp/><sp/><sp/>=<sp/>cooperative_groups::tiled_partition&lt;SUB_WARP_SIZE&gt;(block);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>sub_warp_id<sp/><sp/>=<sp/>subwarp.meta_group_size()<sp/>*<sp/>blockIdx.x<sp/>+<sp/>subwarp.meta_group_rank();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>sub_warp_num<sp/>=<sp/>subwarp.meta_group_size()<sp/>*<sp/>gridDim.x;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>lane_id_in_sub_warp<sp/>=<sp/>subwarp.thread_rank();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory::device_reference&lt;EmbeddingT&gt;<sp/>embedding_dev_ref(embedding_gref);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>embedding_size<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>embedding_desc.sizes[1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>embedding_stride<sp/>=<sp/>embedding_desc.stride;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>output_stride<sp/><sp/><sp/><sp/>=<sp/>output_desc.stride;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>typed_data_vector&lt;EmbeddingT,<sp/>ALIGNMENT&gt;<sp/>embeddings;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>typed_data_vector&lt;OutputT,<sp/>ALIGNMENT&gt;<sp/>outputs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int64_t<sp/>output_idx<sp/>=<sp/>sub_warp_id;<sp/>output_idx<sp/>&lt;<sp/>indice_count;<sp/>output_idx<sp/>+=<sp/>sub_warp_num)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int64_t<sp/>raw_output_idx<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>gather_with_sorted_ids<sp/>?<sp/>(int64_t)(raw_indices[output_idx])<sp/>:<sp/>output_idx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>OutputT*<sp/>output_ptr<sp/>=<sp/>output<sp/>+<sp/>output_desc.storage_offset<sp/>+<sp/>output_stride<sp/>*<sp/>raw_output_idx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>IndexT<sp/>embedding_table_idx<sp/>=<sp/>indices[output_idx];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(embedding_table_idx<sp/>&lt;<sp/>0)<sp/>continue;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int64_t<sp/>embedding_offset<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>embedding_desc.storage_offset<sp/>+<sp/>embedding_table_idx<sp/>*<sp/>embedding_stride;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>emb_idx<sp/>=<sp/>lane_id_in_sub_warp<sp/>*<sp/>ALIGNMENT;<sp/>emb_idx<sp/>&lt;<sp/>embedding_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>emb_idx<sp/>+=<sp/>ALIGNMENT<sp/>*<sp/>SUB_WARP_SIZE)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>mov_data&lt;sizeof(EmbeddingT)<sp/>*<sp/>ALIGNMENT&gt;(&amp;embeddings,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;embedding_dev_ref[embedding_offset<sp/>+<sp/>emb_idx]);</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>unroll</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>sub_idx<sp/>=<sp/>0;<sp/>sub_idx<sp/>&lt;<sp/>ALIGNMENT;<sp/>sub_idx++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typed_data_vector_at(outputs,<sp/>sub_idx)<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>convert_type&lt;EmbeddingT,<sp/>OutputT&gt;(typed_data_vector_at(embeddings,<sp/>sub_idx));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>mov_data&lt;sizeof(OutputT)<sp/>*<sp/>ALIGNMENT&gt;(output_ptr<sp/>+<sp/>emb_idx,<sp/>&amp;outputs);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>EmbeddingT,<sp/>typename<sp/>IndexT,<sp/>typename<sp/>OutputT&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>gather_temp_func(wholememory_gref_t<sp/>embedding_gref,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t<sp/>embedding_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void*<sp/>indices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int64_t<sp/>indice_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>gather_with_sorted_ids,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void*<sp/>raw_indices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void*<sp/>output,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t<sp/>output_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStream_t<sp/>stream,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>gather_sms)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>WHOLEMEMORY_EXPECTS(output_desc.sizes[0]<sp/>==<sp/>indice_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;gather_func,<sp/>output<sp/>shape[0]=%ld,<sp/>but<sp/>indice_count=%ld&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>output_desc.sizes[0],</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>indice_count);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(indice_count<sp/>==<sp/>0<sp/>||<sp/>embedding_desc.sizes[1]<sp/>==<sp/>0)<sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>wm_alignment<sp/>=<sp/>determine_wholememory_alignment_elt_count(embedding_desc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>mm_alignment<sp/>=<sp/>determine_memory_alignment_elt_count(output,<sp/>output_desc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>alignment<sp/><sp/><sp/><sp/>=<sp/>std::min&lt;int&gt;(wm_alignment,<sp/>mm_alignment);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>int<sp/>embedding_size<sp/>=<sp/>embedding_desc.sizes[1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>int<sp/>thread_num<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>wholememory::div_rounding_up_safe&lt;int&gt;(embedding_size,<sp/>alignment);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>thread_num<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>std::min(thread_num,<sp/>512);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>int64_t<sp/>block_count<sp/>=<sp/>indice_count<sp/>&gt;=<sp/>1024<sp/>?<sp/>1024<sp/>:<sp/>static_cast&lt;int&gt;(indice_count);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>(*kernel_fn)(wholememory_gref_t,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IndexT*,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int64_t,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IndexT*,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>OutputT*,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t)<sp/>=<sp/>nullptr;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>switch<sp/>(alignment)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>16:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>kernel_fn<sp/>=<sp/>gather_func_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>OutputT,<sp/>16&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>8:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>kernel_fn<sp/>=<sp/>gather_func_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>OutputT,<sp/>8&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>4:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>kernel_fn<sp/>=<sp/>gather_func_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>OutputT,<sp/>4&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>2:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>kernel_fn<sp/>=<sp/>gather_func_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>OutputT,<sp/>2&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>1:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>kernel_fn<sp/>=<sp/>gather_func_kernel&lt;EmbeddingT,<sp/>IndexT,<sp/>OutputT,<sp/>1&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>default:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>WHOLEMEMORY_FAIL(&quot;gather<sp/>func<sp/>alignment=%d.&quot;,<sp/>alignment);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>block_size<sp/><sp/>=<sp/>1024;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>block_count<sp/>=<sp/>indice_count<sp/>&gt;<sp/>1568<sp/>?<sp/>1568<sp/>:<sp/>indice_count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(gather_sms<sp/>!=<sp/>-1)<sp/>block_count<sp/>=<sp/>gather_sms;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>for<sp/>small<sp/>embedding<sp/>size<sp/>,use<sp/>subwarp<sp/>to<sp/>gather</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>min_threads_per_embedding<sp/>=<sp/>embedding_desc.sizes[1]<sp/>/<sp/>alignment;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(min_threads_per_embedding<sp/>&lt;<sp/>32)<sp/>{</highlight></codeline>
<codeline><highlight class="normal">#define<sp/>SWITCH_GATHER_FUNC_WITH_ALIGNMENT(KERNEL_NAME,<sp/>SUB_WARP_SIZE)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>switch<sp/>(alignment)<sp/>{<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>16:<sp/>{<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>kernel_fn<sp/>=<sp/>KERNEL_NAME&lt;EmbeddingT,<sp/>IndexT,<sp/>OutputT,<sp/>SUB_WARP_SIZE,<sp/>16&gt;;<sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>8:<sp/>{<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>kernel_fn<sp/>=<sp/>KERNEL_NAME&lt;EmbeddingT,<sp/>IndexT,<sp/>OutputT,<sp/>SUB_WARP_SIZE,<sp/>8&gt;;<sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>4:<sp/>{<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>kernel_fn<sp/>=<sp/>KERNEL_NAME&lt;EmbeddingT,<sp/>IndexT,<sp/>OutputT,<sp/>SUB_WARP_SIZE,<sp/>4&gt;;<sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>2:<sp/>{<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>kernel_fn<sp/>=<sp/>KERNEL_NAME&lt;EmbeddingT,<sp/>IndexT,<sp/>OutputT,<sp/>SUB_WARP_SIZE,<sp/>2&gt;;<sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>1:<sp/>{<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>kernel_fn<sp/>=<sp/>KERNEL_NAME&lt;EmbeddingT,<sp/>IndexT,<sp/>OutputT,<sp/>SUB_WARP_SIZE,<sp/>1&gt;;<sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>default:<sp/>{<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>WHOLEMEMORY_FAIL(&quot;gather<sp/>func<sp/>alignment=%d.&quot;,<sp/>alignment);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>\</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>threads_per_embedding<sp/>=<sp/>16;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(min_threads_per_embedding<sp/>&gt;=<sp/>16)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>SWITCH_GATHER_FUNC_WITH_ALIGNMENT(gather_func_sub_warp_kernel,<sp/>16);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>threads_per_embedding<sp/>=<sp/>16;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>if<sp/>(min_threads_per_embedding<sp/>&lt;<sp/>16<sp/>&amp;&amp;<sp/>min_threads_per_embedding<sp/>&gt;=<sp/>8)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>SWITCH_GATHER_FUNC_WITH_ALIGNMENT(gather_func_sub_warp_kernel,<sp/>8);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>threads_per_embedding<sp/>=<sp/>8;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>if<sp/>(min_threads_per_embedding<sp/>&lt;<sp/>8<sp/>&amp;&amp;<sp/>min_threads_per_embedding<sp/>&gt;=<sp/>4)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>SWITCH_GATHER_FUNC_WITH_ALIGNMENT(gather_func_sub_warp_kernel,<sp/>4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>threads_per_embedding<sp/>=<sp/>4;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>if<sp/>(min_threads_per_embedding<sp/>&lt;<sp/>4<sp/>&amp;&amp;<sp/>min_threads_per_embedding<sp/>&gt;=<sp/>2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>SWITCH_GATHER_FUNC_WITH_ALIGNMENT(gather_func_sub_warp_kernel,<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>threads_per_embedding<sp/>=<sp/>2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>SWITCH_GATHER_FUNC_WITH_ALIGNMENT(gather_func_sub_warp_kernel,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>threads_per_embedding<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#undef<sp/>SWITCH_GATHER_FUNC_WITH_ALIGNMENT</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>block_size<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>128;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>max_blocks_per_sm<sp/>=<sp/>8;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>WM_CUDA_CHECK(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>cudaOccupancyMaxActiveBlocksPerMultiprocessor(&amp;max_blocks_per_sm,<sp/>kernel_fn,<sp/>block_size,<sp/>0));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>sm_count<sp/><sp/>=<sp/>100;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>device_id<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>WM_CUDA_CHECK(cudaGetDevice(&amp;device_id));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>WM_CUDA_CHECK(cudaDeviceGetAttribute(&amp;sm_count,<sp/>cudaDevAttrMultiProcessorCount,<sp/>device_id));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>block_count<sp/>=<sp/>indice_count<sp/>&gt;<sp/>1568<sp/>?<sp/>1568<sp/>:<sp/>indice_count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>min_embedding_per_block<sp/>=<sp/>block_size<sp/>/<sp/>threads_per_embedding;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>block_count<sp/>=<sp/>min((int)(indice_count<sp/>+<sp/>min_embedding_per_block<sp/>-<sp/>1)<sp/>/<sp/>min_embedding_per_block,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sm_count<sp/>*<sp/>max_blocks_per_sm<sp/>*<sp/>4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(gather_sms<sp/>!=<sp/>-1)<sp/>block_count<sp/>=<sp/>gather_sms<sp/>*<sp/>max_blocks_per_sm;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>kernel_fn&lt;&lt;&lt;block_count,<sp/>block_size,<sp/>0,<sp/>stream&gt;&gt;&gt;(embedding_gref,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>embedding_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static_cast&lt;const<sp/>IndexT*&gt;(indices),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>indice_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>gather_with_sorted_ids,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static_cast&lt;const<sp/>IndexT*&gt;(raw_indices),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static_cast&lt;OutputT*&gt;(output),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>output_desc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>WM_CUDA_CHECK(cudaGetLastError());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>InputT,<sp/>typename<sp/>IndexT,<sp/>typename<sp/>EmbeddingT,<sp/>int<sp/>ALIGNMENT<sp/>=<sp/>1&gt;</highlight></codeline>
<codeline><highlight class="normal">__global__<sp/>void<sp/>scatter_func_kernel(const<sp/>InputT*<sp/>input,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t<sp/>input_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IndexT*<sp/>indices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int64_t<sp/>indice_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_gref_t<sp/>embedding_gref,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t<sp/>embedding_desc)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto<sp/>block<sp/><sp/>=<sp/>cooperative_groups::this_thread_block();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto<sp/>mywarp<sp/>=<sp/>cooperative_groups::tiled_partition&lt;32&gt;(block);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>__shared__<sp/>char<sp/>shm_in_char[24576];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>InputT*<sp/>all_sh<sp/>=<sp/>reinterpret_cast&lt;InputT*&gt;(shm_in_char);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>InputT*<sp/>my_shared;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>warp_id<sp/>=<sp/>(threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x)<sp/>/<sp/>32;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>lane_id<sp/>=<sp/>threadIdx.x<sp/>%<sp/>32;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>embedding_size<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>embedding_desc.sizes[1];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>embedding_stride<sp/>=<sp/>embedding_desc.stride;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>input_stride<sp/><sp/><sp/><sp/><sp/>=<sp/>input_desc.stride;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>async_copy_align<sp/><sp/><sp/><sp/><sp/>=<sp/>sizeof(InputT)<sp/>&gt;<sp/>4<sp/>?<sp/>1<sp/>:<sp/>4<sp/>/<sp/>sizeof(InputT);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>shm_size<sp/>=<sp/>24576<sp/>/<sp/>sizeof(InputT);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>batch_size<sp/>=<sp/>(shm_size<sp/>/<sp/>(blockDim.x<sp/>/<sp/>32)<sp/>-<sp/>async_copy_align)<sp/>/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>input_stride;<sp/><sp/>//<sp/>indices<sp/>batch<sp/>size<sp/>in<sp/>lines</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>wholememory::device_reference&lt;EmbeddingT&gt;<sp/>embedding_dev_ref(embedding_gref);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>typed_data_vector&lt;EmbeddingT,<sp/>ALIGNMENT&gt;<sp/>embeddings;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>typed_data_vector&lt;InputT,<sp/>ALIGNMENT&gt;<sp/>inputs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>input_off_tail<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>input_desc.storage_offset<sp/>%</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>async_copy_align;<sp/><sp/>//<sp/>this<sp/>is<sp/>crutial<sp/>for<sp/>copy<sp/>alignment,<sp/>4<sp/>bytes<sp/>as<sp/>alignment;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>use_shm<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(batch_size<sp/>&lt;=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>use_shm<sp/><sp/><sp/><sp/>=<sp/>false;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>batch_size<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>my_shared<sp/>=<sp/>all_sh<sp/>+<sp/>shm_size<sp/>/<sp/>(blockDim.x<sp/>/<sp/>32)<sp/>*<sp/>(threadIdx.x<sp/>/<sp/>32);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>for<sp/>(int64_t<sp/>input_idx<sp/>=<sp/>warp_id<sp/>*<sp/>batch_size;<sp/>input_idx<sp/>&lt;<sp/>indice_count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>input_idx<sp/>+=<sp/>gridDim.x<sp/>*<sp/>(blockDim.x<sp/>/<sp/>32)<sp/>*<sp/>batch_size)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>cur_idx_lines<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>(indice_count<sp/>-<sp/>input_idx)<sp/>&gt;<sp/>batch_size<sp/>?<sp/>batch_size<sp/>:<sp/>indice_count<sp/>-<sp/>input_idx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>InputT*<sp/>input_ptr<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>input<sp/>+<sp/>input_desc.storage_offset<sp/>-<sp/>input_off_tail<sp/>+<sp/>input_stride<sp/>*<sp/>input_idx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>this<sp/>variable<sp/>is<sp/>also<sp/>for<sp/>alignment</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(use_shm)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>copy_size<sp/>=<sp/>input_off_tail<sp/>+<sp/>cur_idx_lines<sp/>*<sp/>input_stride;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(input_idx<sp/>+<sp/>cur_idx_lines<sp/>&lt;<sp/>indice_count)<sp/><sp/>//<sp/>input_dim<sp/>*<sp/>sizeof(InputT)<sp/>&gt;<sp/>4<sp/>is<sp/>needed</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>copy_size<sp/>=<sp/>(copy_size<sp/>+<sp/>async_copy_align<sp/>-<sp/>1)<sp/>/<sp/>async_copy_align<sp/>*<sp/>async_copy_align;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>copy_size<sp/>*=<sp/>sizeof(InputT);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>cooperative_groups::memcpy_async(mywarp,<sp/>my_shared,<sp/>input_ptr,<sp/>copy_size);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>cooperative_groups::wait(mywarp);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>e<sp/>=<sp/>0;<sp/>e<sp/>&lt;<sp/>cur_idx_lines;<sp/>e++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>int64_t<sp/>embedding_table_idx<sp/>=<sp/>indices[input_idx<sp/>+<sp/>e];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(embedding_table_idx<sp/>&lt;<sp/>0)<sp/>continue;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>EmbeddingT*<sp/>emb_ptr<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;embedding_dev_ref[embedding_desc.storage_offset<sp/>+<sp/>embedding_table_idx<sp/>*<sp/>embedding_stride];</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>emb_idx<sp/>=<sp/>lane_id<sp/>*<sp/>ALIGNMENT;<sp/>emb_idx<sp/>&lt;<sp/>embedding_size;<sp/>emb_idx<sp/>+=<sp/>ALIGNMENT<sp/>*<sp/>32)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(use_shm)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mov_data&lt;sizeof(InputT)<sp/>*<sp/>ALIGNMENT&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;inputs,<sp/>my_shared<sp/>+<sp/>input_off_tail<sp/>+<sp/>e<sp/>*<sp/>input_stride<sp/>+<sp/>emb_idx);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mov_data&lt;sizeof(InputT)<sp/>*<sp/>ALIGNMENT&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;inputs,<sp/>input_ptr<sp/>+<sp/>input_off_tail<sp/>+<sp/>e<sp/>*<sp/>input_stride<sp/>+<sp/>emb_idx);</highlight></codeline>
<codeline><highlight class="normal">#pragma<sp/>unroll</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>sub_idx<sp/>=<sp/>0;<sp/>sub_idx<sp/>&lt;<sp/>ALIGNMENT;<sp/>sub_idx++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>typed_data_vector_at(embeddings,<sp/>sub_idx)<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>convert_type&lt;InputT,<sp/>EmbeddingT&gt;(typed_data_vector_at(inputs,<sp/>sub_idx));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mov_data&lt;sizeof(EmbeddingT)<sp/>*<sp/>ALIGNMENT&gt;(emb_ptr<sp/>+<sp/>emb_idx,<sp/>&amp;embeddings);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>mywarp.sync();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">template<sp/>&lt;typename<sp/>InputT,<sp/>typename<sp/>IndexT,<sp/>typename<sp/>EmbeddingT&gt;</highlight></codeline>
<codeline><highlight class="normal">void<sp/>scatter_temp_func(const<sp/>void*<sp/>input,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t<sp/>input_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void*<sp/>indices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int64_t<sp/>indice_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_gref_t<sp/>embedding_gref,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t<sp/>embedding_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStream_t<sp/>stream,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>scatter_sms)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>WHOLEMEMORY_EXPECTS(input_desc.sizes[0]<sp/>==<sp/>indice_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;scatter_func,<sp/>input<sp/>shape[0]=%ld,<sp/>but<sp/>indice_count=%ld&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>input_desc.sizes[0],</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>indice_count);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(indice_count<sp/>==<sp/>0<sp/>||<sp/>embedding_desc.sizes[1]<sp/>==<sp/>0)<sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>wm_alignment<sp/>=<sp/>determine_wholememory_alignment_elt_count(embedding_desc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>mm_alignment<sp/>=<sp/>determine_memory_alignment_elt_count(input,<sp/>input_desc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>alignment<sp/><sp/><sp/><sp/>=<sp/>std::min&lt;int&gt;(wm_alignment,<sp/>mm_alignment);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>(*kernel_fn)(const<sp/>InputT*,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>IndexT*,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int64_t,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_gref_t,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wholememory_matrix_description_t)<sp/>=<sp/>nullptr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>switch<sp/>(alignment)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>16:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>kernel_fn<sp/>=<sp/>scatter_func_kernel&lt;InputT,<sp/>IndexT,<sp/>EmbeddingT,<sp/>16&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>8:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>kernel_fn<sp/>=<sp/>scatter_func_kernel&lt;InputT,<sp/>IndexT,<sp/>EmbeddingT,<sp/>8&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>4:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>kernel_fn<sp/>=<sp/>scatter_func_kernel&lt;InputT,<sp/>IndexT,<sp/>EmbeddingT,<sp/>4&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>2:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>kernel_fn<sp/>=<sp/>scatter_func_kernel&lt;InputT,<sp/>IndexT,<sp/>EmbeddingT,<sp/>2&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>case<sp/>1:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>kernel_fn<sp/>=<sp/>scatter_func_kernel&lt;InputT,<sp/>IndexT,<sp/>EmbeddingT,<sp/>1&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>default:<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>WHOLEMEMORY_FAIL(&quot;scatter<sp/>func<sp/>alignment=%d.&quot;,<sp/>alignment);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>block_size<sp/><sp/>=<sp/>256;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>block_count<sp/>=<sp/>indice_count<sp/>&gt;<sp/>1568<sp/>?<sp/>1568<sp/>:<sp/>indice_count;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(scatter_sms<sp/>!=<sp/>-1)<sp/>block_count<sp/>=<sp/>scatter_sms;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>kernel_fn&lt;&lt;&lt;block_count,<sp/>block_size,<sp/>0,<sp/>stream&gt;&gt;&gt;(static_cast&lt;const<sp/>InputT*&gt;(input),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>input_desc,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>static_cast&lt;const<sp/>IndexT*&gt;(indices),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>indice_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>embedding_gref,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>embedding_desc);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>WM_CUDA_CHECK(cudaGetLastError());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">}<sp/><sp/>//<sp/>namespace<sp/>wholememory_ops</highlight></codeline>
    </programlisting>
    <location file="src/wholememory_ops/functions/gather_scatter_func.cuh"/>
  </compounddef>
</doxygen>
